Урок 05 (Понедельник - 06.01.2025)
Тема: Inheritance & Polymorphism.
======================================================================================================
Ключевые разделы:

1) Концепция наследования.
2) Виды наследования
3) Перегрузка методов
4) Переопределение методов
5) Абстрактные классы и их использование
6) Интерфейсы. Реализация нескольких интерфейсов.
7) Методы интерфейсов, их реализация.
8) Константы в интерфейсах.
9) Расширение интерфейсов другими интерфейсами.

======================================================================================================
1) КОНЦЕПЦИЯ НАСЛЕДОВАНИЯ

Наследование (Inheritance) - принцип ООП который реализуется через наследование и перенятие состояния и поведения
присущего родительскому классу дочерними классами, при помощи ключевого слова extends.
Позволяет существенно уменьшить количество кода.
*
======================================================================================================
2) ВИДЫ НАСЛЕДОВАНИЯ

В Java доступны следующие виды наследования:
  * Одноуровноевое (Single-level inheritance) - это когда у суперкласса есть один наследник:
                                        (Prnt) <- (Chld)
  * Многоуровневое (Multi-level inheritance) - с участием двух и более классов наследников:
                                 (Prnt) <- (Chld) <- (Sub-Chld) ++
  * Иерархическое (Hierarchical inheritance) - Один класс служит суперклассом (базовым классом) для
    нескольких производных классов:
                                                (Prnt)
                                           /      |       \
                                      (Chld_1) (Chld_2) (Chld_3)

 *** Множественное и гибридное наследование для классов в JAVA ЗАПРЕЩЕНО!! Это сделано воизбежании возникновения
 иерархических коллизий, когда например у Вас есть два супер-класса с идентичным методом, компилятор не сможет решить
 какую из реализаций ему использовать.

 У класса может быть только один суперкласс/родительский класс/базовый класс/верхнеуровневый класс.
*
======================================================================================================
3) ПЕРЕГРУЗКА МЕТОДОВ

Перегрузка методов (Methods Overloading) – перегруженные методы отличаются по количеству и типу аргументов,
переданных в метод.

Хорошим примером служит метод valueOf() класса String, который имеет около десяти перегруженных вариантов
с различными типами параметров на вход ((int i), (char c), (long l), (double d), (float f), (boolean b), (char[] data),
(char[] data, int offset, int count)).

Перегрузка методов является примером статического полиморфизма, раннего связывания (static binding).
При раннем связывании компилятор определяет, какой метод и где нужно вызвать.
*
======================================================================================================
4) ПЕРЕОПРЕДЕЛЕНИЕ МЕТОДОВ

Переопределение методов (Methods Overriding) - заимствование классом наследником метода родительского класса
с возможностью изменения его реализации под наследника.

Для удобства распознания переопределения используется аннотация @Override
*
===============================================================================================
5) АБСТРАКТНЫЕ КЛАССЫ И ИХ ИСПОЛЬЗОВАНИЕ

Абстрактный класс – класс помеченный ключевым словом abstract, ограниченный класс.
Главное и основное отличие его от обычных классов состоит в том что мы не можем создать экземпляр (обьект)
абстрактного класса, соответственно, не можем вызвать его конструктор:

- Может иметь конструкторы (которые могут быть переопределены в наследниках).
- Может иметь|не иметь абстрактные методы без реализации (которые должны по контракту переопределены в наследниках)!!!
- Может иметь поля (состояние).
- Может иметь константы.
- Может иметь обычные методы с реализацией.

Любой класс имеющий хотя бы один абстрактный метод (метод без реализации) обязан быть обьявлен как абстрактный класс!

В чем состоит смысл создания абстрактного класса без абстрактных методов?
В том что вы не можете создать обьект такого класса. Пример http servlet..
*
======================================================================================================
6) ИНТЕРФЕЙСЫ. РЕАЛИЗАЦИЯ НЕСКОЛЬКИХ ИНТЕРФЕЙСОВ.

Интерфейс – это конструкция которая описывает определенное поведение обьекта.
Примеры интерфейсов List, Throwable, Serializable, Iterable, Cloneable, Autocloseable.

- Все методы без реализации в интерфейсах по умолчанию являются public abstract.
- В интерфейсах могут быть дефолтные методы с реализацией с ключевым словом default, и эти методы уже могут быть
  вызваны в классах наследниках.
- Так же в интерфейсах могут быть методы с реализацией с идентификатором доступа private. Такие методы не могут быть
  вызваны в наследниках, но могут быть вызваны в дефолтных методах с реализацией у самого итерфейса .
  И служат для того что бы не перегружать дефолтные методы обьемом, для читаемости.

- Так же интерфейсы могут реализовывать статические методы, но помним что статика это ЗЛО!

Преимущества интерфейсов:

- Множественное наследование. Интерфейсы поддерживают множественное наследование, что позволяет классу реализовать
  несколько интерфейсов, способствуя гибкости дизайна.
- Обеспечение исполнения контракта. Интерфейсы определяют контракт, к которому должны соблюдаться классы реализации,
  обеспечивая согласованность между различными реализациями.
- Уменьшенная связь. Поскольку интерфейсы определяют только контракт, классы реализации не тесно связаны друг с другом.

Недостатки интерфейсов:

- Отсутствие поддержки конструкторов. Интерфейсы не могут иметь конструкторов, что затрудняет исполнение требований
  инициализации.
- Обратная совместимость. Добавление метода к интерфейсу может нарушить существующие реализации, что требует
  тщательной осмотрительности в написании кода.
*
======================================================================================================
7) МЕТОДЫ ИНТЕРФЕЙСОВ И ИХ РЕАЛИЗАЦИЯ.

Ключевое слово final это модификатор запрещения доступа, если обьявить final:
- Класс - нельзя наследоваться от этого класса.
- Метод - наследники не могут переопределить методы с модификатором final.
- Поле - final поле не может быть изменено (нельзя перезаписать ссылку на другой обьект),
  значения задаются только через конструктор при инициализации обьекта.

  Также модификатор final в Java используется при создании констант.

  Константа - это статическая переменная (а значит принадлежит классу в котором обьявлена),
  она final (а значит не может быть изменена), константа получает свое значение при инициализации
  и затем неизменяема. Имена констант пишутся в UPPER CASE.

  Структура при обьявлении:
  public static final <Datatype> <UPPER_CASE_NAME>;

  Пример вызова:
  Math.PI - константа Пи класса java.lang.Math
*
======================================================================================================
8) КОНСТАНТЫ В ИНТЕРФЕЙСАХ.

В интерфейсах все поля по умолчанию являются константами и неявно обьявлены как public static final.
Поскольку конструкторы и блоки инициализации в интерфейсах запрещены, то значения полям интерфейса обязаны
быть присвоены при обьявлении.

Недостатки определения констант в интерфейсе:

 - Интерфейс ОПРЕДЕЛЯЕТ тип и общее поведение. Значение констант являются своеобразными деталями реализации, и,
    определяя константы в интерфейсе, раскрываем детали реализации, что не good;
 - Загрязнение пространства имен является побочным эффектом. Константы, указанные в интерфейсе, также доступны
    по имени реализующего класса и подклассов. Запутано видеть одну константу, определенную в интерфейсе и доступную
    с использованием нескольких имен классов/подклассов в кодовой базе.
 - Если мы решим использовать интерфейс только для определения констант, синтаксически невозможно запретить классам
    не реализовывать интерфейс.
*
======================================================================================================
9) РАСШИРЕНИЕ ИНТЕРФЕЙСОВ ДРУГИМИ ИНТЕРФЕЙСАМИ.

Интерфейсы могут наследовать (расширять) другие интерфейсы при помощи ключевого слова extends, в отличии от классов
для интерфейсов разрешается как множественное, так и гибридное наследование.
*
======================================================================================================