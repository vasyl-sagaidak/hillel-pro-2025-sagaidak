Урок 14 (Понедельник - 10.02.2025)
Тема: COLLECTIONS FRAMEWORK
======================================================================================================
Ключевые разделы:

0) ITERATOR INTERFACE / java.util.Collections.class
1) ПОНЯТИЕ КОЛЛЕКЦИЙ В JAVA
2) JAVA COLLECTIONS FRAMEWORK
3) ИЕРАРХИЯ КОЛЛЕКЦИЙ В JAVA
4) INTERFACE LIST И ЕГО РЕАЛИЗАЦИИ
5) INTERFACE SET И ЕГО РЕАЛИЗАЦИИ
6) INTERFACE QUEUE И ЕГО РЕАЛИЗАЦИИ
7) INTERFACE DEQUE И ЕГО РЕАЛИЗАЦИИ
8) ДОПОЛНИТЕЛЬНЫЕ МАТЕРИАЛЫ

======================================================================================================
0) ITERATOR INTERFACE / java.util.Collections.class

 Iterator - это интерфейс у которого в каждой из реализаций той или иной структуры данных в Collections Framework
 есть своя реализация (реализация этого Iterator).

 У итератора есть три основных метода:

 boolean hasNext() - проверяет, имеется ли в коллекции следующий по порядку элемент (не закончилась ли она). Если
                     есть, метод возвращает true, иначе - false.
 Object next() - этот метод возвращает следующий элемент коллекции. Если элемент не обнаружен, то метод выбрасывает
                 исключение NoSuchElementException.
 void remove() - этот метод удалает текущий элемент. Важный момент состоит в том, что сначала этот элемент нужно
                 получить с помощью метода next(), если мы вызовем метод remove() до метода next(), то мы получим
                 исключение IllegalStateException.

При попытке пройтись циклом по коллекции и при совпадении элемента указанным в сравнении, выполнить операцию удаления
 данного элемента мы получаем ConcurrentModificationException.

 for (String s : list) {
    if (s.equals("C")) {
    list.remove(s); // ConcurrentModificationException...
    }
 }

 Можно ли модифицировать коллекцию при итерировании?
 ОТВЕТ НЕТ!!! Потому что, это не логично, так как итерирование это процесс последовательного перебирания элементов
 коллекции, от 1го до последнего, пока не дойдем до конца. Во время итерирования мы не должны играться с размером коллекции.

                                                    Fail-fast iterators:

 Fail-fast iterators фейлятся как только понимают что структура коллекции которую они лопатят, притерпела изменения с
 момента начала процесса итерации. Структурные изменения означают добавление, удаление либо обновление какого либо
 элемента из коллекции, в то время как один поток выполняет итерацию этой коллекции.

 Поведение отказоустойчивости реализуется путем сохранения состояния коллекции (количества изменений), и если поток
 итерации выявляет изменение состояния (количества изменений), он выбрасывает исключение ConcurrentModificationException.

                                                    Fail-safe iterators:

Fail-safe iterator не выдает никаких исключений когда коллекция изменяется структурно во время, когда один поток
выполняет итерацию по ней. Трюк в том что fail-safe итераторы работают с клоном исходящей коллекции вместо самой
коллекции.

 Iterator как реализация - это обьект который реализует интерфейсы Iterator либо ListIterator.
 Iterator позволяет нам получить доступ ко всем элементам коллекции и удалять те из них, которые необходимо.

 ListIterator является наследником Iterator и позволяет нам пробегаться по коллекции в обоих направлениях.
 ListIterator так-же позволяет нам изменять элементы.
 Для того, чтобы использовать итератор, прежде всего необходимо получить его. Для этого необходимо использовать метод
 listIterator().

                                                         СOLLECTIONS CLASS

 В пакете java.util. имеется java.util.Collections, это утилитарный класс содержащий дополнительные методы для работы
 с коллекциями. Сам по себе класс очень похож на java.util.Arrays;.

 Collections.sort(list); // отсортировать список
 Collections.copy(toList,fromList); // скопировать один список в другой
 Collections.min(list); // найти наименьший элемент
 Collections.max(list); // найти наибольший элемент
 Collections.min(list,comparator); // найти наименьший элемент с использованием компаратора
 Collections.max(list,comparator); // найти найбольший элемент с использованием компаратора
 Collections.unmodifiableList(list); // превратить список в неизменяемый
 Collections.emptyList(); // создать пустой неизменяемый список

*
======================================================================================================
1) ПОНЯТИЕ КОЛЛЕКЦИЙ В JAVA

Коллекции (Collections) – это хранилища или контейнеры, поддерживающие различные способы накопления и упорядочения
объектов с целью обеспечения возможностей эффективного доступа к ним.

Коллекции представляют собой реализацию абстрактных структур данных, поддерживающих основные операции:

    - добавление нового элемента в коллекцию;
    - удаление элемента из коллекции;
    - изменение элемента в коллекции.

Для хранения множества однотипных данных могут использоваться массивы, но они не всегда являются идеальным решением.
Длина массива задается заранее. Однако, если количество элементов заранее неизвестно, придется либо выделять память
«с запасом», либо предпринимать сложные действия по выделению памяти для массива.

Элементы массива имеют жестко заданные места размещения, поэтому, например, удаление элемента из массива перестает
быть простой операцией.

Чтобы избавиться от этих недостатков используются рекурсивные типы данных, такие как списки и деревья.

Стандартный набор коллекций Java служит для лишения необходимости самостоятельно реализовывать эти типы данных и
предоставляет дополнительные возможности.

Коллекции Java – классы, основная цель которых – сохранять наборы элементов.

*
======================================================================================================
2) JAVA COLLECTIONS FRAMEWORK

    Коллекция – набор элементов (обьектов).
    -	В некоторых коллекциях можно хранить дубликаты, в других – нельзя.
    -	Некоторые коллекции можно сортировать, другие – нельзя.

    Java Collections Framework – это набор классов и интерфейсов.

    Главным интерфейсом в Java Collections Framework является интерфейс Collection, который в свою очередь наследуется
    от интерфейса Iterable.
    Конкретной имплементации интерфейса Collection не имеет, однако, существуют имплементации более узких интерфейсов:
     List, Set и Queue.

    Интерфейс List<E> extends Collection <E>:
    1)	Индексация, можно обратиться к элементу по определенному порядковому номеру.
    2)	List<E> позволяет иметь дубликаты.

    Интерфейс Set<E> extends Collection<E>:
    1)	В Set<E> нельзя иметь дубликаты.
    2)	В Set<E> нельзя получить элемент по индексу.

    Интерфейс Queue<E> extends Collection<E>:
    Так-же наследует интерфейс Collection и описывает такую структуру данных как Checker.
    Работает по принципу FIFO  First In, First Out.

*
======================================================================================================
3) ИЕРАРХИЯ КОЛЛЕКЦИЙ В JAVA

 Главным интерфейсом в Коллекциях является интерфейс Iterable, от него наследуется интерфейс Collection,
 от которого в свою очередь наследуются интерфейсы List, Queue и Set, у каждого из которых имеется ряд
 дефолтных реализаций.

                                         Interface "Iterable"
                                                  |
                                        Interface "Collection"
                                /                  |                  \
                   Interface "List"       |---Interface "Queue"      Interface "Set"
                              |           |           |                   |  |
                   Class "ArrayList"      |  Class "PriorityQueue"        |  |-- Class "HashSet"
                              |           |                               |  |-- Class "LinkedHashSet"
                   Class "LinkedList" -|  |--- Interface "Deque"        |
                              |        |               |                Interface "SortedSet"
                   Class "Vector"      |------- Class "ArrayDeque"                      |
                              |                                                   Class "TreeSet"
                   Class "Stack"

Так же имеется итерфейс Map который хотя и входит в состав фреймворка, но держится обособленно. В отличии от остальных
интерфейсов в Коллекциях, реализации интерфейса Map в качестве значения оперируют парами <Кey, Value>.

                                              Interface "Map"
                                                    |--------------------- Class "HashTable"
                                                    |                   |
                                                    |                   |- Class "LinkedHashMap"
                                           Interface "SortedMap"        |
                                                    |                   |- Class "HashMap"
                                                    |
                                               Class "TreeMap"

Сollection - общий интерфейс позволяющий нам работать с группами обьектов.

Интерфейс List - наследует интерфейс Сollection и является упорядоченным списком элементов.
Интерфейс Set - наследует интерфейс Сollection и хранит множество уникальных элементов.
Интерфейс SortedSet - наследует интерфейс Set и является упорядоченной структурой данных хранящую множество ункальных
                      элементов.
Map - структура данных хранящая уникальные элементы типа "ключ-значение".
Map.Entry - описывает элемент в Map. Внутренний класс Map.
SortedMap - расширяет интерфейс Map и сортирует элементы по возрастанию.

Enumeration - интерфейс, который определяет методы для "перебора" элементов в коллекциях.
Iterator - способ доступа к элементам коллекций.

*
======================================================================================================
4) INTERFACE LIST И ЕГО РЕАЛИЗАЦИИ

ArrayList, Vector, LinkedList – типичные представители интерфейса List. Чаще всего на практике используют
ArrayList и LinkedList. LinkedList, в свою очередь, так-же является реализацией итерфейса Queue.

    .size(); - узнать размер листа.
    .isEmpty(); - узнать пустой или нет. Возвращает булеан значение.
    .add(); - добавить значение в лист.
    .get(); - достать значение из листа.
    .set(int, E) – поместить значение в лист по индексу (с заменой).
    .add(int, E) – добавить значение в лист по индексу (со сдвигом вправо всех значений).
    .remove(E) – удалить значение из листа по индексу.
    .clear(); - удаляет все элементы листа.

Все эти методы принадлежат интерфейсу List и доступны в любой имплементации, будь то LinkedList, ArrayList или
собственные имплементации интерфейса List.

List.remove(Integer.valueOf(100)) – пример удаления значение по индексу.

ArrayList - аналог массива, удобен для чтения/записи данных по индексу.
LinkedList - связный список, удобный и более быстрый для чтения/записи в средину и конец списка.

Вцелом, в современном Java ArrayList в большинстве случаев более продуктивен и лучше.

                                                ARRAY LIST

Класс ArrayList является имплементацией интерфейса List, который, в свою очередь, наследует интерфейс Collection.

Под капотом у ArrayList лежит массив обьектов - transient Object[] elementData;

По дефолту, размер нового ArrayList - private static final int DEFAULT-CAPACITY = 10;

Когда заканчивается место в ArrayList, то метод .grow() под капотом добавляет
list.length = list.length + ½ list.length;

Threshold = (Load Factor) * (Current Capacity)
Threshold = Load Factor * Current Capacity = 0.5 * 10 = 5;

При имплементации интерфейса List мы обязаны всегда переопределять методы:
    - boolean isEmpty();
    - boolean add(E e);
    - E get (int index);
    - boolean remove(Object o);

В ArrayList можно работать с null и дубликатами.
При привышении размера, ArrayList увеличивается в 1,5 раза, при этом создается новый, больший по размеру ArrayList,
а старый в него копируется, все это происходит в методе .grow();.

Основные методы класса ArrayList:

.add(E element) – добавляет новый элемент в конец списка. Возвращает boolean значение (true – успех, false – не добавлено).
ArrayList<String> list = new ArrayList<>();
list.add("Hello");

.add(int index, E element) – добавляет элемент element в позицию index. При добавлении происходит сдвиг всех элементов
справа от указанного индекса на 1 позицию вправо.
list.add(0, "Amigo");

.addAll(Collection <? Extends E> collection) – добавление всех элементов коллекции collection в список в порядке их
расположении в collection.

.addAll(int index, Collection <? Extends E> collection) – добавление всех элементов collection в список начиная
с индекса index. При этом все элементы сдвинутся вправо на количество элементов в списке collection.

ArrayList<String> secondList = new ArrayList<>();
secondList.addAll(list);
System.out.println("Первое добавление: " + secondList);
secondList.addAll(1, list);
System.out.println("Второе добавление в середину: " + secondList);
Вывод:
Первое добавление: [Amigo, Hello]
Второе добавление в середину: [Amigo, Amigo, Hello, Hello]

Методы addAll() также возвращают boolean-результат добавления элементов.

.clear() – удаление всех элементов из списка.

.clone() – возвращает обьект-копию массива:
ArrayList<String> copyOfSecondList = (ArrayList<String>) secondList.clone();
secondList.clear();
System.out.println(copyOfSecondList);
Вывод:
[Amigo, Amigo, Hello, Hello]

Следует обратить внимание, что метод clone() возвращает Object, так что после его вызова потребуется сделать приведение
к необходимому классу. При клонировании создается новый независимый объект. В примере показано, как очищение
клонированного объекта не сказалось на составе его клона.

.contains(Object o) – проверка наличия обьекта в списке, возвращает boolean-значение.

System.out.println(copyOfSecondList.contains("Hello"));
System.out.println(copyOfSecondList.contains("Сheck"));

Вывод:
true
false

.ensureCapacity(int minCapacity) – увеличивает размер внутреннего массива, чтобы в него поместилось количество
элементов, переданных в minCapacity. Если массив достаточно вместителен, никакие преобразования не производятся.

Этот метод полезен, когда возникает потребность вместить большое количество элементов в несколько итераций.
Например, при создании списка емкость его внутреннего массива – 10.
При загрузке данных по сети они обрабатываются асинхронно, порциями и результаты помещаются в массив.
Если ожидается доставка 10 000 элементов, может быть неэффективно просто добавлять эти данные каждый раз:
достаточно будет в начале обработки вызвать метод ensureCapacity(10000) и записывать туда данные по мере необходимости.

.forEach(Consumer<? super E> action) – обработать в цикле ArrayList можно стандартными спбами, цикл for:
// Первый способ
for(int i = 0; i< secondList.size(); i++) {
   System.out.println(secondList.get(i));
}
И цикл for-each:
// Второй способ
for(String s : secondList) {
   System.out.println(s);
}
В классе ArrayList есть метод для обработки каждого элемента, который называется также, forEach.
В качестве аргумента передается реализация интерфейса Consumer, в котором нужно переопределить метод accept():
secondList.forEach(new Consumer<String>() {
   @Override
   public void accept(String s) {
       System.out.println(s);
   }
});
Вывод:
Amigo
Amigo
Hello
Hello

Метод accept принимает в качестве аргумента очередной элемент того типа, который хранит в себе ArrayList.
Пример для Integer:
ArrayList<Integer> integerList = new ArrayList<>();
integerList.forEach(new Consumer<Integer>() {
    @Override
    public void accept(Integer integer) {
        System.out.println(integer);
    }
});

Метод action() будет выполнен для каждого элемента.

.get(int index) - возвращает элемент, который расположен в указанной позиции списка.
Если index меньше 0 или index больше/равно максимального количества элементов списка, будет выброшено исключение
IndexOutOfBoundsException.
Это основной метод получения элемента из списка, время извлечения элемента по индексу всегда будет одинаковым,
независимо от размера ArrayList.

.indexOf(Object o) - метод возвращает индекс первого вхождения элемента в списке. Если элемента не существует
в списке, метод вернет -1.

.isEmpty() - метод возвращает true, если список пустой, false в обратном случае.
Если в списке содержатся только элементы null, метод вернет false. Иными словами, null элементы также учитываются
этим методом.

iterator() - возвращает итератор для списка для последующего использования в цикле или при любой другой обработке.
Итератор для ArrayList — fail-fast. Это значит, что если коллекция изменится во время итерации, будет выброшено
исключение ConcurrentModificationException.

.lastIndexOf(Object o) - функционал метода похож на indexOf(Object o), отличие в том, что возвращается индекс
последнего элемента в списке. Если элемент не найден, также возвращает -1.

.remove(int index) - удаление элемента в указанной позиции индекса. После удаления сдвигает все элементы влево
для заполнения освободившегося пространства.
Если index<0 или >= количество элементов списка, будет выброшено исключение IndexOutOfBoundsException.
В результате метод возвращает элемент, который был удален.

.remove(Object o) - метод удаляет из списка переданный элемент o. Если элемент присутствует в списке, он удаляется,
а все элементы смещаются влево. Если элемент существует в списке и успешно удален, метод возвращает true,
в обратном случае — false.

.removeAll(Collection<?> c) - если необходимо удалить несколько элементов, не стоит делать это в цикле по условию:
гораздо удобнее и безопаснее воспользоваться методом removeAll(). Он принимает коллекцию элементов, которая будет
удалена из списка.
Коллекция должна содержать элементы того же типа, которые хранит целевой список. В обратном случае будет выброшен
ClassCastException. Метод вернет true, если список был изменен в результате вызова метода.

.set(int index, E element) - замена элемента в указанной позиции index на переданный element. Индекс также
должен быть больше нуля и меньше индекса последнего элемента, иначе будет выброшено исключение
IndexOutOfBoundsException.

.size() - лучший способ (практически единственный) для того, чтобы узнать размер массива.

.sort(Comparator<? super E> c) - сортировка списка по заданному правилу. Правило сортировки представляет собой
реализованный интерфейс Comparator с переопределенным методом compareTo().
Переопределение нужно, если коллекция содержит объекты собственного класса. При работе со стандартными классами
(Integer, String и так далее) переопределение compareTo() требуется только для нестандартной сортировки.

.toArray() - превращает список в фиксированный массив. Обратите внимание, что метод возвращает массив объектов
(Object[]). Если необходимо привести список в массив объектов определенного типа, в качестве параметра в метод
можно передать массив, куда будут перемещены элементы списков.
Пример:
String[] array = new String[secondList.size()];
secondList.toArray(array);
for(int i = 0; i< array.length; i++) {
   System.out.println(array[i]);
}
Вывод:
Amigo
Amigo
Hello

Hello

                                                 LINKED LIST
LinkedList - это связный список ссылок на элементы. Таким образом, для доступа к элементу в центре,
необходимо производить поиск с самого начала и до конца списка. С другой стороны, добавление и удаление
элемента в LinkedList происходит быстрее чем в ArrayList по той причине, что эти операции всего лишь
изменяют сам список (переприсваивают ссылки на соседние ноды, а не создают новый массив и копируют
старый в него как в ArrayList).

Контейнер LinkedList оптимизирован для последовательного доступа с быстрыми операциями вставки/удаления
в средине списка. Произвольный доступ к элементам в LinkedList выполняется довольно медленно, т.к.
требует полного перебора элементов. Класс представляет структуру данных связанного списка и реализует
интерфейсы List, Deque, Queue.

Поиск в LinkedList происходит за O(n). Получение и вставка значений за О(n/2).

*
======================================================================================================
5) INTERFACE SET И ЕГО РЕАЛИЗАЦИИ

*
======================================================================================================
6) INTERFACE QUEUE И ЕГО РЕАЛИЗАЦИИ

*
======================================================================================================
7) INTERFACE DEQUE И ЕГО РЕАЛИЗАЦИИ

*
======================================================================================================
8) ДОПОЛНИТЕЛЬНЫЕ МАТЕРИАЛЫ

    Collections Framework Overview.
                https://docs.oracle.com/javase/8/docs/technotes/guides/collections/overview.html

    Guide to the Java ArrayList.
                https://www.baeldung.com/java-arraylist

    A Guide to the Java LinkedList.
                https://www.baeldung.com/java-linkedlist

    A Guide to HashSet in Java.
                https://www.baeldung.com/java-hashset

    A Guide to TreeSet in Java.
                https://www.baeldung.com/java-tree-set

    Immutable Set in Java.
                https://www.baeldung.com/java-immutable-set

    Guide to the Java Queue Interface.
                https://www.baeldung.com/java-queue

    Introduction to the Java ArrayDeque.
                https://www.baeldung.com/java-array-deque

*
======================================================================================================