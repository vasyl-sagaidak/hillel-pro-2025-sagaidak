Урок 13 (ЧЕТВЕРГ - 06.02.2025)
Тема: ПРОДВИНУТАЯ СИНХРОНИЗАЦИЯ
======================================================================================================
Ключевые разделы:

1) ОБЬЕКТЫ БЛОКИРОВАНИЯ
2) СИНХРОНИЗАТОРЫ JAVA (part 1)
3) СИНХРОНИЗАТОРЫ JAVA (part 2)
4) EXECUTORS

======================================================================================================
1) ОБЬЕКТЫ БЛОКИРОВАНИЯ

LOCK OBJECTS (OБЬЕКТЫ БЛОКИРОВАНИЯ) - работают так же, как неявные блокирования, используемые синхро-
низованным кодом.

Ключевое слово synchronized в Java внутренне использует встроенное блокирование, связанное с обьектом,
для получения моментального доступа к полям-членам обьекта.

Традиционный способ достигнуть синхронизации потоков в Java состоит в использовании ключевого слова
synchronized. Хотя оно обеспечивает определенную базовую синхронизацию, ключевое слово synchronized
довольно жосткое в использовании. Например, поток может взять блокировку только один раз. Синхрони-
зированные блоки не предлагают никакого механизма очереди ожидания и после выхода с одного потока
любой поток может взять блокирование. Это может привести к недостатку ресурсов для любого другого
потока в течении очень продолжительного времени.

Вместо использования встроенного блокирования при помощи ключевого слова synchronized можем использовать
разные классы блокирования, предоставленные Java Concurrency API, что бы иметь более точный контроль
механизма блокирования.

Interface Lock предоставляет более гибкую альтернативу внутреннему блокированию (синхронизированные блоки/методы).
Он позволяет явное блокирование и разблокирование, поддерживает разные стратегии блокирования и предоставляет
определенные дополнительные функции. Найболее часто используемой реализацией является Class ReentrantLock.
https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html

Class ReentrantLock - повторное блокирование взаимного исключения с тем же базовым поведением и семантикой,
что и явное блокирование монитора, доступ к которому осуществляется при помощи синхронизованных методов и
операторов, но с расширенными возможностями.
https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantLock.html

Class ReentrantLock - взаимоисключающее блокирование с тем же поведением, что и встроенное/неявное блокирование,
доступ к которому осуществляется через ключевое слово synchronized.

Class ReentrantLock имеет реентерабельные характеристики. Это означает что поток которому в данный момент принадлежит
блокирование может получить его более одного раза без каких либо проблем, то-есть пере-войти (re-entrant).

Class ReentrantLock предоставляет определенные функиции, такие как: возможность прерывания,
попытка получить блокирование, если оно не удерживается другим потоком, и поток, который ожидает блокирование
в течении определенного периода.

НЕДОСТАТКИ Class ReentrantLock в Java:
 - Если метод lock() не используется правильно, когда метод lock() не вызывается непосредственно перед блоком try
   и не разблокируется в блоке finally, блокировка может не разблокироваться в случае возникновения какого-либо
   исключения.
 - Метод unlock() должен вызываться явно столько раз, сколько раз вызывается метод lock() в потоке, иначе блокировка
   не будет снята, что вызывает проблемы с производительностью.
 - Программы, к которым обращаются многие потоки, могут иметь более низкую общую пропускную способность.

 НЕОБХОДИМО принять решение на основе того, нужна ли гибкость, предлагаемая Clacc ReentrantLock.

 Interface ReadWriteLock обеспечивает способ различать блокировку чтения и записи. Это позволяет нескольким потокам
 одновременно читать общий ресурс, обеспечивая эксклюзивный доступ для записи. Class ReentrantReadWriteLock
 является стандартной реализацией этого интерфейса, поддерживающего семантику, подобную Class ReentrantLock.
 https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReadWriteLock.html
 https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html

 Interface ReadWriteLock поддерживает пару связанных блокировок: одно для операций только чтения и одно только
 для записи. Блокировка чтения может удерживаться одновременно несколькими потоками чтения, пока нет записывающих.
 Блокировка записи является монопольной.

 Interface ReadWriteLock обеспечивает повышенный уровень параллелизма. Он работает лучше по сравнению с другими
 блокировками в приложениях, где операций записи меньше, чем операций чтения.

*
======================================================================================================
2) СИНХРОНИЗАТОРЫ JAVA (part 1)

В Java, путем совместного доступа к полям и объектам, достигается связь потоков. Взаимодействие потоков и
непротиворечивость памяти – некоторые из ПРОБЛЕМ, возникающих из-за взаимодействия потоков. Эти проблемы можно
устранить с помощью синхронизации.

Однако ЗАДЕРЖКА может быть вызвана синхронизацией при доступе к блокировке или объекту, который в данный момент
удерживается другим потоком. Пока другой поток не снимет блокировку объекта, ожидающий поток НЕ МОЖЕТ использовать
этот объект. Это состояние называется конфликтом потоков.

Java предоставляет классы для общей синхронизации специального назначения (вспомогательные утилиты для синхронизации
потоков) – синхронизаторы (synchronizers). Пакет java.util.concurrent.

Class Semaphore (Семафор)
https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Semaphore.html

Чтобы ограничить доступ потока к определенному ресурсу, используется семафор. Ряд разрешений потока инициируется
при создании объекта семафора. До тех пор, пока СЧЕТЧИК РАЗРЕШЕНИЙ не станет больше нуля, метод получения
блокируется и принимает его, если он доступен, и уменьшает счетчик разрешений. Для освобождения блокирующего
потока используется метод release.

Class CountDownLatch (Защелка обратного отсчета)
https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html

В Class CountdownLatch один или несколько потоков настроены на ОЖИДАНИЕ завершения набора операций в других потоках.
Инициализируется количество потоков для ожидания. Пока счетчик не достигнет нуля, метод ожидания блокируется.

УСЛОВИЯ. Лодка вмещает определенное количество (N) пассажиров. Утечка лодки происходит только после заполнения всех
N мест. РЕАЛИЗАЦИЯ.
(1) Запускаем основной поток.
(2) Создаем экземпляр Class CountDownLatch с начальным счетчиком
(count=N, для N потоков). Class CountDownLatch определяет конструктор CountDownLatch(int count). Счетчик является
количеством потоков, которые должна ждать защелка (latch). Это значение можно установить только один раз.
Class CountDownLatch не предоставляет ни одного механизма для сброса счетчика.
(3) Создаем и запускаем N потоков.
(4) Вызываем CountDownLatch.await() из основного потока. Этот основной поток должен вызывать метод await()
сразу после запуска других потоков. Исполнение остановится на методе await(), пока другие потоки не завершат
выполнение.
(5) Вызываем метод CountDownLatch.countDown() по завершении выполнения каждого потока. Другие N потоков должны
иметь ссылку на объект-защелку, потому что им нужно будет сообщить объекту Class CountDownLatch о том, что они
выполнили свою задачу. Это сообщение производится методом countDown(). Каждый вызов метода уменьшает на
первоначальный счетчик, установленный в конструкторе.
(6) Восстанавливаем основной поток. Когда все N потоков вызывают метод countDown(), счетчик достигает нуля, и
основному потоку разрешается восстановить исполнение после метода await().

*
======================================================================================================
3) СИНХРОНИЗАТОРЫ JAVA (part 2)

*
======================================================================================================
4) EXECUTORS

*
======================================================================================================