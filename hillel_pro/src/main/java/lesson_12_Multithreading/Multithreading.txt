УРОК 12 (ПОНЕДЕЛЬНИК - 03.02.2025)
ТЕМА: МНОГОПОТОЧНОСТЬ (MULTITHREADING)
======================================================================================================
КЛЮЧЕВЫЕ РАЗДЕЛЫ:

1) МНОГОПОТОЧНОСТЬ. ПРОЦЕСС. ПОТОК.
2) МАНИПУЛЯЦИЯ ПОТОКАМИ Ч1-Ч4.
3) ПРИОРИТЕТЫ ПОТОКОВ.
4) ГЛАВНЫЙ ПОТОК.
5) ПОТОКИ-ДЕМОНЫ.
6) ПРОБЛЕМЫ МНОГОПОТОЧНОСТИ.
7) АТОМАРНЫЕ ПЕРЕМЕННЫЕ.
8) СИНХРОНИЗАЦИЯ ПОТОКОВ.
9) МЕЖПОТОКОВОЕ ВЗАИМОДЕЙСТВИЕ.

======================================================================================================
1) МНОГОПОТОЧНОСТЬ. ПРОЦЕСС. ПОТОК.

Многопоточность (Multithreading) - процесс одновременного выполнения нескольких потоков.

Поток(Thread) - легковесная еденица процесса, которая используется в многопоточной среде.

Процесс имеет автономную среду выполнения, полный приватный набор основных ресурсов времени выполнения;
в частности, каждый процесс имеет собственное пространство в памяти.

И процессы, и потоки обеспечивают среду выполнения, но для создания нового потока нужно меньше ресурсов,
чем для создания нового процесса.

Потоки существуют внутри процесса - каждый процесс имеет внутри себя как минимум один поток. Потоки
совместно используют ресурсы процесса, включая его память и открытые файлы.

Поток - независимый, виртуальный и последовательный поток управления (control flow) внутри процесса.

При выполнении процесса он включает в себя набор потоков, каждый поток использует общую область памяти.
Каждый поток выполняет задание независимо от другого потока.

Программу можно разделить на несколько небольших процессов. Каждый небольшой процесс можно рассматривать
как отдельный поток (облегченный процесс). Можно думать о легком процессе как о виртуальном ЦП (CPU),
который выполняет код либо системные вызовы.

МНОГОПОТОЧНЫЕ ПРОГРАММЫ ВКЛЮЧАЮТ В СЕБЯ два или более потоков, которые могут выполняться одновременно, и
каждый поток определяет отдельный способ выполнения. Одна программа может выполнять две или более задач
одновременно.

НАПРИМЕР, один поток записывает содержимое в файл, тогда как другой поток выполняет проверку орфографии.

В многопоточной среде программы, которые используют преимущества многопоточности, используют максимальное
время ЦП, поэтому ВРЕМЯ ПРОСТОЯ можно свести к минимуму.

ПРЕИМУЩЕСТВА МНОГОПОТОЧНОСТИ:

- НЕ БЛОКИРУЕТ пользователя, потоки независимые, можно выполнять несколько операций одновременно;
- выполнение многих операций одновременно ЭКОНОМИТ ВРЕМЯ;
- независимость потока НЕ ВЛИЯЕТ НА ДРУГИЕ ПОТОКИ, если возникает исключение в другом потоке.

НАПРИМЕР, серверная программа, которая прослушивает некоторый порт для входящих запросов. Когда запрос получен
, он обрабатывает запрос, а потом возвращается к прослушиванию. Если обработка запроса занимает много времени,
то новые клиенты не могут посылать запросы на сервер в течении этого времени. Запросы можно получить только во
время прослушивания сервером.

АЛЬТЕРНАТИВНЫЙ ВАРИАНТ состоит в том, что поток, который прослушивает, передает запрос рабочему потоку и немедленно
возвращается к прослушиванию.

ТО ЖЕ САМОЕ ВЕРНО И для настольных приложений. Если вы нажимаете кнопку, которая запускает долгую задачу, а поток,
который выполняет задачу, является потоком, который обновляет окна, кнопки и.т.п., то программа не будет отвечать
на запросы во время выполнения задачи.

ВМЕСТО ЭТОГО, задача может быть передана рабочему потоку. Пока рабочий поток занят задачей, оконный поток может
отвечать на запросы других пользователей. Когда рабочий поток завершает работу, сигнализирует оконному потоку. Поток
окна может потом обновить окна программы с результатом задания.
Программа с дизайном рабочего потока будет казаться пользователю более отзывчивой.

ЭТАПЫ ЖИЗНЕННОГО ЦИКЛА ПОТОКА в Java:
    - Новый (New)
    - Запускаемый (Runnable)
    - Исполняемый (Running)
    - Ожидающий (Waiting)
    - Мертвый (Dead)

СПОСОБЫ СОЗДАНИЯ ПОТОКА в Java:
- Способом имплементации Interface Runnable
- расширением Class Thread

Interface Runnable должен быть реализован всяким классом, экземпляры которого предназначены для выполнения потоком.
Interface Runnable является функциональным интерфейсом и имеет на борту всего один метод, run().

Class Thread предоставляет конструкторы и методы для создания и выполнения операций над потоком.
Class Thread расширяет Class Object и реализует Interface Runnable.

Class Thread vs Interface Runnable:

Если расширим Сlass Thread, наш класс не сможет расширить какой либо другой класс, поскольку Java, как известно,
не поддерживает множественное наследование. Но если мы реализуем Interface Runnable, наш класс все еще может
расширять другие базовые классы.

Мы можем достигнуть базовой функциональности потока расширяя Class Thread, потому что он предоставляет определенные
встроенные методы, которые, в свою очередь, не предоставляются Interface Runnable.

Использование Interface Runnable дает нам обьект который может быть использован несколькими потоками.

ЧТО КАСАЕТСЯ ПОТОКОВ, СЛЕДУЕТ УЧИТЫВАТЬ НЕКОТОРЫЕ ВЕЩИ:

- Переключение контекста (например, предоставление доступа к ЦП другому потоку) - сложная и тяжелая операция. Следует
стараться минимизировать ее возникновение.

- Создание потока стоит дорого. Каждый поток имеет свой собственный стек вызовов, счетчик программ и регистры. Большее
количество потоков приводит к более интенсивному использованию памяти.

- Что касается параллельности, цель состоит в том, что бы использовать поток полностью.

*
======================================================================================================
2) МАНИПУЛЯЦИЯ ПОТОКАМИ Ч1-Ч4.

Class Thread предоставляет определенные методы для манипулирования потоками. Для понимания процесса работы с потоками
рассмотрим некоторые из них.

ВНИМАНИЕ. РЕЗУЛЬТАТ ВЫПОЛНЕНИЯ ПРОГРАММ может зависить от некоторых факторов: операционная систеа, настройки JVM на
конкретной локальной машине. Если есть несколько потоков, то, какой поток получит шанс выполнения первым по очереди,
решает Планировщик потоков (Thread Scheduler). Планировщик потоков является частью JVM. Поведение планировщика потоков
зависит от поставщика JVM, и потому мы не можем ожидать гарантированного одинакового результата кадый раз при выполне-
нии программы.

                                                  Методы run() и start().

Методы run() и start(). Мы можем вызвать метод run(), но тогда он будет вести себя как обычный метод, и мы не сможем
воспользоваться преимуществами многопоточности. Когда метод запуска вызывается при помощи метода start(), тогда для
выполнения метода запуска выделяется новый отдельный поток, по-этому, если больше одного потока вызывают метод start()
, это означает, что их метод запуска выполняется отдельными потоками (эти потоки выполняются одновременно).

С другой стороны, если метод run() этих потоков вызывается непосредственно, тогда выполнение всех их обрабатывается
одним и тем же текущим потоком, и многопоточность не будет иметь места, потому исходящие данные будут отображать
последовательное выполнение потоков в указаном порядке.

                                                       Meтод sleep().

Метод sleep() заставляет текущий поток останавливать выполнение на указанный период. Это эффективный способ предостав-
ления процессорного времени другим потокам программы либо другим программам, которые могут работать в компьютерной
системе.

При вызове Thread.sleep():
 - JVM попросит базовую ОС предоставить потоковый доступ к ЦП в течении определенного времени.
 - На этот период времени поток полностью заблокирован для обработки новых задач. Поток полностью заблокирован и не
   будет выполнять никаких других задач до тех пор, пока не закончится время сна.
 - После окончания этого времени ОС разбудит поток (путем прерывания) и предоставит доступ к ЦП для возобновления с
   того места, где он остановился.

НО:
 - Thread.sleep() является блокирующей операцией. Блокирует поток на определенное количество миллисекунд.
 - Thread.sleep() может усложнить тестирование, повлиять на поведение нашей программы и сбить с толку других разработ-
   чиков, которым необходимо вникнуть в наш код.

                                                     Meтод join().

Метод join() используется для удержания выполнения текущего потока до тех пор, пока указанный поток не
будет мертвым (завершит выполнение).

                                                    Метод isAlive().
По сути, этот метод внутренне работает очень близко параллельно этапам жизненного цикла потока. Он проверяет,
жив ли данный поток. Поток жив, если он был запущен и еще не умер. Существует переходный период между выполнением
потока и моментом, когда поток не выполняется. После возвращения из метода run() происходит небольшой промежуток
времени, прежде чем поток остановится. Если мы хотим знать, был ли вызван метод запуска класса потока либо поток
был завершен, мы должны использовать метод isAlive(). Этот метод используется, чтобы узнать, действительно ли поток
был запущен и еще не завершился.

                                                     Метод yield().
Метод yield(). Поток, вызванный методом yield(), временно останавливает выполнение, что бы дать возможность потокам
того же уровня приоритета шанс на выполнение. Если нет ожидаемого потока либо все потоки, которые ожидают, имеют
низкий приоритет. Тогда тот самый поток получит возможность немедленного выполнения.

                                                   Метод interrupt().
Метод interrupt() позволяет прервать спящий или ожидающий поток. Прерывание - указание потоку, о том что он должен
остановить то, что он делает, и заняться чем то другим. Разработчик должен решить, каким именно образом поток
отреагирует на прерывание, но часто поток завершается. Каждый раз, когда вызываем метод interrupt(), можем не сразу
увидеть эффект, если целевой поток находится в спящем режиме, либо режиме ожидания, он будет немедленно прерван.
Если целевой поток не пребывает в состоянии сна или ожидания, то вызов прерывания будет ожидать, пока целевой поток
не войдет в состояние сна или ожидания. Как только целевой поток войдет в состояние сна или ожидания, он вступит
в силу немедленно. За время своего существования, если целевой поток никогда не переходил в спящее состояние либо
состояние ожидания, вызов прерывания не влияет на него, просто вызов прерывания будет использован зря.

Метод interrupt() проверяет, не был ли прерван текущий поток. Прерванное состояние потока очищается этим методом.
Другими словами, если бы этот метод вызывался два раза подряд, второй вызов вернул бы false (если бы текущий поток
не был прерван снова после того, как первый вызов очистил свой статус прерванного и до того, как второй вызов
проверил его). Возвращает true, если текущий поток был прерван, иначе false.
*
======================================================================================================
3) ПРИОРИТЕТЫ ПОТОКОВ.

КАЖДЫЙ ПОТОК В JAVA ИМЕЕТ ОПРЕДЕЛЕННЫЙ ПРИОРИТЕТ. В большинстве случаев планировщик потоков планирует потоки
в соответствиии с их приоритетом (так называемое предварительное планирование) и зависимо от спецификации JVM.
Разработчик может также явно назначать приоритеты Java-программе.

ПРИОРИТЕТЫ ПОТОКОВ - ЦЕЛЫЕ ЧИСЛА, которые определяют то, как следует обрабатывать один поток по отношению к другим.
Диапазон допустимых приоритетов потоков составляет 1 - 10 ( 1 - наименьший, а 10 - наибольший).

Class Thread определяет константы для некоторых стандартных приоритетов: MIN_PRIORITY - 1 (минимальный),
NORM_PRIORITY - 5 (по умолчанию), MAX_PRIORITY - 10 (максимальный).

Приторитет потока решает когда переключаться с одного запущенного потока на другой, процесс называется
ПЕРЕКЛЮЧЕНИЕМ КОНТЕКСТА. Поток может добровольно отдать управление, и поток с наиболее высоким приоритетом,
находящийся в состоянии готовности к выполнению, получает ЦП.

Поток, может быть вытеснен потоком с более высоким приоритетом не зависимо от того, что делает поток с более низким
приоритетом. Каждый раз, когда поток с более высоким приоритетом хочет запуститься, он это делает.

ПЛАНИРОВЩИК ПОТОКОВ ИСПОЛЬЗУЕТ ПРИОРИТЕТЫ во время распределения ЦП. Поток с найвысшим приоритетом получит шанс на
выполнение первым. Если два потока имеют одинаковый приоритет, то, какой из них получит шанс на выполнение, решает
планировщик потоков, который зависит от поставщика JDK. Имеется ввиду то, что мы не можем ожидать гарантированного
прогнозируемого результата.

Приоритет по умолчанию для основного потока только 5, а для всех других потоков приоритет будет унаследован из
родительского класса.

*
======================================================================================================
4) ГЛАВНЫЙ ПОТОК.

Многопоточная программа состоит из двух или более частей, которые могут выполняться одновременно. Каждая часть
такой программы называется потоком, и каждый поток определяет свой собственный отдельный путь выполнения.

Когда программа Java запускается, всегда немедленно начинает выполняться один поток. Обычно его называют
ОСНОВНЫМ/ГЛАВНЫМ (main) ПОТОКОМ ПРОГРАММЫ, ПОТОМУ ЧТО ОН ВЫПОЛНЯЕТСЯ ВО ВРЕМЯ ЗАПУСКА ПРОГРАММЫ.

МЕТОД main() ЯВЛЯЕТСЯ ТОЧКОЙ ВХОДА ДЛЯ ВЫПОЛНЕНИЯ ПРОГРАММЫ. Таким образом, когда JVM начинает выполнение программы,
она создает поток для ее запуска и этот поток называется основным/главным потоком. Главный поток сначала проверяет
существование метода main(), а потом инициализируем его класс. Начиная с JDK 6, метод main() является обязательным
в отдельном Java-приложении.

Свойства связанные с основным потоком:
    - Это поток, из которого будут созданы другие дочерние потоки.
    - Часто это должен быть последний поток для завершения выполнения программы, поскольку он выполняет разные
      действия по завершению работы.

ОСНОВНОЙ ПОТОК СОЗДАЕТСЯ АВТОМАТИЧЕСКИ ВО ВРЕМЯ ЗАПУСКА ПРОГРАММЫ. Что бы управлять им, мы должны получить ссылку на
него. Это можно сделать, вызывая метод currentThread(), который определен в Class Thread. Этот метод возвращает
ссылку на поток, в котором он вызывается.

Приоритет основного потока по умолчанию равен 5, а для остальных пользовательских потоков приоритет будет унаследован
от родительского к дочернему.

*
======================================================================================================
5) ПОТОКИ-ДЕМОНЫ.

ДЕМОН-ПОТОК (Daemon Thread) В JAVA - ПОТОК С НИЗКИМ ПРИОРИТЕТОМ, КОТОРЫЙ РАБОТАЕТ В ФОНОВОМ РЕЖИМЕ для выполнения
таких вспомагательных задач как сборка мусора (удаление из памяти обьектов, которые не используются), удаление
ненужных записей из кеша.

Демон-поток в Java также является потоком поставщика услуг, который предоставляет услуги потоку пользователя. Его
жизнь зависит от потоков-пользователей, тесть когда все потоки-пользователи погибают, JVM автоматически завершает
Демон-поток.

ОСОБЕННОСТИ ДЕМОН-ПОТОКОВ в Java:
    - Не могут препятствовать завершению JVM когда все потоки-пользователи завершают свое выполнение.
    - JVM завершает их работу, когда все потоки-пользователи заканчивают свое выполнение.
    - Если JVM обнаруживает работающий Демон-поток, то JVM завершает этот поток и после этого выключает его.
      JVM все равно, запущен Демон-поток или нет.
    - Это поток с критически низким приоритетом.

*
======================================================================================================
6) ПРОБЛЕМЫ МНОГОПОТОЧНОСТИ.

Распространенными проблемами многопоточности могут быть:
    - Состояние гонки (Race condition),
    - Взаимное блокирование (Deadlock).

    CОСТОЯНИЕ ГОНКИ (Race condition) - проблема многопоточности, которая может возникнуть внутри критической секции.
    Критическая секция - секция кода, которая выполняется несколькими потоками и в которой последовательность
    выполнения потоков влияет на результат одновременного выполнения критической секции. Когда резульат нескольких
    потоков выполняющих критическую секцию может отличаться в зависимости от последовательности, в которой
    выполняются потоки, говорят что критическая секция содержит состояние гонки.

    Термин "Race Condition" происходит от метафоры, согласно которой потоки проходят через критическую секцию
    и результат этой гонки влияет на результат выполнения критической секции.

    DEADLOCK (Взаимное блокирование) может возникнуть в ситуации когда поток ожидает блокирования обьекта, получе-
    нного другим потоком, а другой поток ожидает блокирования обьекта полученного первым потоком.

    ()   ()
       Х
     о   о

*
======================================================================================================
7) АТОМАРНЫЕ ПЕРЕМЕННЫЕ.

Java в пакете java.util.concurrent.atomic предлагает набор классов, поддерживающих безблоковое потокобезопасное
программирование для отдельных переменных.

Использование классов, содержащихся в этом пакете, гарантирует атомарность операций для int, long, boolean значений,
а также ссылок на объекты и массивы без использования явной синхронизации или блокировки.

Атомарные классы используют инструкции сравнения и замены – CAS (Compare and Swap) – для обеспечения целостности
данных с использованием неблокирующих алгоритмов. Поэтому эти классы считаются более быстрыми, чем блокировка,
когда один поток получает блокировку объекта, другие потоки блокируются.

.addAndGet(int delta) - атомарно добавляет заданное значение для текущего значения. Возвращает обновленное значение.
.compareAndSet(boolean expect, boolean update) - атомарно заменяет текущее значение на заданное обновленное значение,
                                                 если текущее значение равно (==) ожидаемому значению.
.compareAndSet(int expect, int update) - устанавливает значение в переданное значение в параметре, если текущее
                                         значение равно ожидаемому значению, которое так же передается в качестве
                                         параметра. Метод возвращает логическое значение, которое дает представление о
                                         том, было ли выполнено обновление значения.
.decrementAndGet() - уменьшает исходное значение на единицу и возвращает значение после обновления.
.getAndIncrement() - увеличивает исходное значение на единицу и возвращает значение, которое было до обновления.
.getAndSet(boolean newValue) - атомарно устанавливает заданное новое значение и возвращает предыдущее значение, которое
                               было до замены.


Рассмотрим примеры Class AtomicBoolean и Class AtomicInteger.
*
======================================================================================================
8) СИНХРОНИЗАЦИЯ ПОТОКОВ.

Синхронизация (Synchronization) - процесс обработки доступа к ресурсам с помощью нескольких запросов.

Основная цель синхронизации - избежать вмешательства потоков. Иногда, когда несколько потоков пытаются получить
доступ к общему ресурсу, необходимо убедиться, что ресурс будет использоваться только одним потоком в каждый момент
времени.

Когда есть несколько потоков в приложении, иногда возикает НЕОБХОДИМОСТЬ СИНХРОНИЗИРОВАТЬ их относительно определенного
метода либо блока кода.

Обычно это происходит КОГДА НЕСКОЛЬКО ПОТОКОВ АСИНХРОННО ОБНОВЛЯЮТ ОДНИ И ТЕ ЖЕ ДАННЫЕ.

Чтобы ГАРАНТИРОВАТЬ, ЧТО ЭТИ ПЕРЕМЕННЫЕ СОГЛАСУЮТСЯ во всем приложении, мы должны убедиться, что один поток не может
начать обновление данных до того, как другой поток закончит чтение или обновление тех же данных.

ЕСЛИ ПОЗВОЛИМ этому произойти, данные останутся в несогласованном состоянии, и один или оба потока не получат
правильный результат.

Java позволяет определять критические области кода с помощью оператора synchronized. Метод или блок кода синхронизи-
руются с классом, объектом или массивом в зависимости от контекста ключевого слова synchronized.

СИНХРОНИЗОВАННЫЙ МЕТОД используется для блокирования обьекта любого общего ресурса.
КОГДА ПОТОК ВЫЗЫВАЕТ синхронизованный метод, он автоматически получает блокирование для этого обьекта и освобождает
его, когда поток завершает задание.

ЕСЛИ хотим синхронизировать доступ к обьекту класса либо только к части метода, который синхронизируется, мы можем
использовать для этого СИНХРОНИЗИРОВАННЫЙ БЛОК. Он может синхронизировать любую часть обьекта и метода.

СИНХРОНИЗИРОВАННЫЙ БЛОК используется для блокировки объекта любого общего ресурса. Область синхронизированного блока
меньше метода.

ПРОДУКТИВНОСТЬ СИСТЕМЫ может ухудшиться из-за более медленной работы ключевого слова synchronized.

Синхронизированный блок Java эффективнее чем синхронизированный метод Java.
*
======================================================================================================
9) МЕЖПОТОКОВОЕ ВЗАИМОДЕЙСТВИЕ.

МЕЖПОТОКОВОЕ ВЗАИМОДЕЙСТВИЕ (Inter-Thread communication) - ВОЗМОЖНОСТЬ синхронизованным потокам взаимодействовать
друг с другом.

МЕЖПОТОКОВОЕ ВЗАИМОДЕЙСТВИЕ - МЕХАНИЗМ, в котором поток прекращается в своем критическом разделе, а в другом потоке
разрешается войти (или заблокироваться) в том же критическом разделе для выполнения.

Реализовывается методами: Class Object: wait(), notify(), notifyAll().

wait() заставляет текущий поток снимать блокирование и ждать, пока другой поток не вызовет notify() либо notifyAll()
для этого обьекта, либо пока не закончится указанное количество времени.

ТЕКУЩИЙ ПОТОК должен обладать монитором этого обьекта, поэтому он должен вызываться только из синхронизированного
метода, иначе он вызовет исключение.

КОНЦЕПЦИЯ МОНИТОРА. Монитор можно представить как коробку, в которой может быть только один поток. Как только поток
входит в монитор, все другие потоки должны ждать до тех пор, пока этот поток не выйдет из монитора.

notify() будит один поток, который ожидает на мониторе этого обьекта. Если на этом обьекте ожидают какие-то потоки,
один из них выбирается для пробуждения. Выбор произвольный и происходит по усмотрению реализации.

notifyAll() пробуждает все потоки, которые ожидают монитора этого обьекта.

КОГДА ИСПОЛЬЗОВАТЬ МЕТОД notify() И notifyAll()?

В случае взаимоисключающей блокировки только один из ожидаемых потоков может сделать что-нибудь полезное после
получения сообщения (в этом случае получить блокировку). В этом случае лучше использовать notify().

При правильной реализации могли бы использовать notifyAll() и в этой ситуации, но как лишнее мы разбудили бы потоки,
которые все равно ничего не могут сделать.

В некоторых случаях все ожидаемые потоки могут совершить полезные действия после завершения ожидания. Примером может
служить набор потоков, ожидающих завершения определенной задачи; как только задача завершена, все ожидающие потоки
продолжат свою работу.

В таком случае необходимо использовать notifyAll() для одновременного пробуждения всех ожидаемых потоков.

*
======================================================================================================