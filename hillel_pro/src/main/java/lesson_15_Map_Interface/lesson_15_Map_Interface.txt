Урок 15 (ЧЕТВЕРГ - 13.02.2025)
Тема: ИНТЕРФЕЙС MAP И ЕГО РЕАЛИЗАЦИИ
======================================================================================================
Ключевые разделы:

1) СТРУКТУРА ДАННЫХ "СЛОВАРЬ"
2) БАЗОВЫЕ РЕАЛИЗАЦИИ ИНТЕРФЕЙСА MAP
3) КЛАСС HASH-MAP
4) КЛАСС LINKED-HASH-MAP
5) КЛАСС TREE-MAP
6) ДОПОЛНИТЕЛЬНЫЕ МАТЕРИАЛЫ

======================================================================================================
1) СТРУКТУРА ДАННЫХ "СЛОВАРЬ"

СЛОВАРЬ (DICTIONARY) в структуре данных - ЭТО НЕ УПОРЯДОЧЕННАЯ КОЛЛЕКЦИЯ ЭЛЕМЕНТОВ ДАННЫХ, которые
используются для хранения данных в форме ключ-значение. Структура данных словаря содержит атрибут под
названием ключ, который помогает найти данные или значение в памяти.

Dictionary по структуре данных можно сравнить с обычным языковым словарем, где слово действует как key,
а его значение - как value.

КЛЮЧИ В DICTIONARY УНИКАЛЬНЫ и похожи на реальный словарь в реальном (традиционном) языке. Поскольку ключи
являются уникальными (в словаре не может быть двух одинаковых ключей), мы можем легко получить значение
связанное с конкретным ключом.

КЛЮЧ (key) В СЛОВАРЕ ОБЯЗАН СООТВЕТСТВОВАТЬ ПРАВИЛАМ:

- Ключ должен быть уникальным и состоять из одного элемента. Уникальность ключа помогает быстрее и легче
  получать по нему соответствующий набор значений.

- Поскольку в словаре не допускаются дубликаты ключей, всякий раз, когда дубликат ключа найден, последнее
  указанное значение рассматривается как окончательная пара ключ-значение. Итак, если вставим дубликат ключа,
  исходные данные будут потеряны.

- Ключ чувствителен к регистру, поэтому "KEY" это не то же, что "key".

- Ключ должен быть иммутабельным, поэтому мы не можем иметь массив или список в качестве ключа. В качестве
  ключа могут выступать числа, строки или любой другой иммутабельный обьект.

ЗНАЧЕНИЕ (value) В СЛОВАРЕ МОГУТ быть представлены одним значением либо набором таковых, которые хранятся в
каком-либо последовательном типе данных, например MAP.

ОПЕРАЦИИ НАД ДАННЫМИ В CТРУКТУРЕ ДАННЫХ - СЛОВАРЬ (DICTIONARY):

Словарь, как структура данных, используется для хранения данных в парах ключ-значение и манипуляций с
этими данными.

ВСТАВКА ДАННЫХ. Очевидно, что кадлая структура данных хранит данные, вставленные в нее. Важно упомянуть
что атрибуту key можно назначать долько иммутабельные данные, такие как числа, строки итп. С другой
стороны, атрибут value может содержать одно значение, обьект или последовательность значений. Данные вставляются
в словарь только тогда, когда в словаре нет такой пары ключ-значение. Если такая пара ключ-значение уже была
помещена в словарь ранее, старая пара ключ-значение будет заменена новой.

ОБНОВЛЕНИЕ ДАННЫХ. Значение любого элемента данных можно легко обновить. Сначала необходимо получить доступ
к значению с помощью ключа, а потом обновить соответствующие значения.

УДАЛЕНИЕ ДАННЫХ. Можем удалить пару ключ-значение в словаре, получив доступ к атрибуту key. Необходимо знать
что если ключ в словаре отсутствует и мы пытаемся удалить значение несуществующего ключа то может вылететь
ошибка.

ПРОВЕРКА ДАННЫХ. Можем проверить, существует ли определенный ключ в словаре или нет.

Сложность операций в Словаре можем рассматривать через призму его непосредственной реализации. В Java речь
пойдет про крассы реализации интерфейса Map.

*
======================================================================================================
2) БАЗОВЫЕ РЕАЛИЗАЦИИ ИНТЕРФЕЙСА MAP

Interface Map предназначен для создания структур данных в виде словаря, где каждый элемент имеет определенные
ключ и значение. В отличии от других интерфейсов коллекций, Map не наследуется от Interface Collection.

Interface SortedMap - Interface Map, что дополнительно обеспечивает полное упорядочивание своих ключей.
Является аналогом Interface SortedSet для Interface Map.

Interface NavigableMap – Interface SortedMap, расширенный методами навигации, которые возвращают ближайшие
совпадения для заданных целей поиска. Доступ к Interface NavigableMap и перемещение по нему можно выполнять
как по возрастанию, так и по низхождению ключей.

Платформа Java предлагает классы реализации интерфейса Map общего назначения: Class HashMap, Class LinkedHashMap,
Class TreeMap. Их поведение и продуктивность аналогичны Class HashSet, Class LinkedHashSet, Class TreeSet.

Class HashMap используется если необходима максимальная скорость и важен порядок итераций.

Class LinkedHashMap используется если нужна продуктивность близкая к HashMap, но при этом присутствует
итерация порядка вставки.

Class TreeMap используется если нужны операции Interface SortedMap либо итерация представления коллекции
с упорядочиванием по ключу.

*
======================================================================================================
3) КЛАСС HASH-MAP

Неупорядоченная коллекция.
Может содержать один null в качестве ключа и множество null как значения.

В основе HashMap лежит масив. Элементами данного массива являются структуры LinkedList.
Данные структуры LinkedList и заполняются элементами, которые мы добавляем в HashMap.

Map<Student, Double> map = new HashMap<>();

При создании нового обьекта hashmap под капотом создается массив table размером в
16 бакетов.

Каждый бакет данного массива может содержать несколько наших пар Key-Value, которые мы будем добавлять в
наш hashmap, по-этому для того, что бы этот бакет мог содержать несколько пар Key-Value, эти пары обьединяются
в LinkedList, то-есть каждый бакет массива будет содержать LinkedList.

Посмотрим как работает метод put когда мы добавляем элемент в hashmap:
map.put(st1, 7.5);
1)	В первую очередь идет проверка того, равен ли null наш key, если равен, то этот элемент помещается на нулевой индекс

При создании HashMap мы можем задать 2 параметра, которые очень влияют на производительность:

•	Initial capacity – начальный размер массива table (default: 16)
•	Load Factor – коефициент того, насколько массив table должен быть заполнен, после чего его размер будет
увеличен вдвое. (default 0.75)
16 бакетов по умолчанию * 0.75 лоад фактор = 12 бакетов, это значит что после того как в нашем массиве будет
занято 12 бакетов, он увеличится вдвое и станет 32 бакета. И все элементы HashMap будут заново перехешированы.
Будет снова определяться на какой индекс нового массива будет определен тот или иной элемент и уже возможно
наши LinkedList находящиеся в бакетах будут распределены более равномерно по общему пространству массива бакетов.
Чем большее значение initial capacity мы указываем при создании HashMap, тем больше памяти будет занимать наш
 массив, но тем меньшего размера LinkedList’ы будут образовываться внутри конкретной позиции массива (бакета),
 и поиск будет происходить быстрее. То-есть мы можем пожертвовать памятью, но выиграть во времени доступа к элементу.
Чем больше значение load factor, тем больше мы будем экономить памяти, но поиск элемента в мапе будет занимать
большее количество времени. Вцелом 0.75 это золотая средина между экономией памяти и экономией времени,
поэтому в большинстве случаев это не меняют.
Очень важно правильно реализовать hashCode для обеспечения лучшей производительности класса HashMap.
Чем лучше реализован hashCode, тем оптимальнее будут использоваться buckets в HashMap.

Скорость работы HashMap?
Вычисление хешкода ключа и поиск нужного бакета происходит очень быстро, в основном мы тратим время на то,
что бы пройтись по LinkedList`у в поиске необходимого элемента в бакете, операция итерации по LinkedList
занимает у нас О(n) – линейное время. Тоесть чем более распределенная у нас HashMap, и чем меньшего
размера LinkedList`ы в наших бакетах, тем быстрее у нас поиск элементов. А это распределение в свою
очередь напрямую зависит от качества реализации hashCode функции, поскольку если hashCode будет
просчитываться примитивно, то у нас будут формироваться длинные LinkedList`ы из за возникновения
большого количества коллизий и это значительно будет тормозить работу мапы.
Вставка и получение элемента из HashMap – O(1) – константное время.
put() и get() – O(n) – линейное время.

В Java 8 для предотвращения образования таких длинных LinkedList предприняли некоторую оптимизацию.
После того как связный список в бакете достигает размера в 8 нод он превращается в (сбалансированное)
красно-черное дерево.

Сбалансированное дерево
Это такая структура данных у которой больший элемент всегда находится справа, а меньший слева.
       Скорость поиска по сбалансированным деревьям составляет O(log n) – логарифмическое время.
       Что быстрее чем поиск по связным спискам О(n) – линейное время.

Ключи в HashMap должны быть immutable, как это сделать?
1)	Обьявить класс final
2)	Поля класса сделать так-же final

Поскольку поиск в мапе производится сначала по hashCode, и только в том случае если hashCode совпадают,
то мы проверяем по equals, если ключи в HashMap не будут immutable, и мы например положим какое то
значение в мапу по неиммутабельному ключу, а потом сделаем какое то изменение у обьекта ключа
(например поменяем значение какого-то поля), в тот момент когда нам нужно будет вытащить значение
из мапы у нас ничего не получится, потому как ключ который находится в мапе, и тот ключ который мы
подаем на вход стали различными по хешкоду.

HashMap и Multithreading?
HashMap не является синхронизированной, ее не нужно использовать в многопоточном программировании,
она для этого не предназначена. Для этого существует коллекция ConcurrentHashMap.

МЕТОДЫ HashMap:

put(K key, V value) - связывает указанное значение с указанным ключом в мапе. Если такой ключ уже есть
                      в мапе то новый ключ со значением перетрут собой старые.

putIfAbsent(K key, V value) - если указанный ключ еще не связан со значением (либо связан с null), данный
                              метод связывает его с заданным значением и возвращает null, иначе возвращает
                              текущее значение.

putAll(Map<? extends K,? extends V> m) - вливает мапу в нашу мапу, если какие либо ключи у обоих мап окажутся
                                         идентичными, то пары которые вливаются перетрут собой пары в которых
                                         возник метч по ключам.

get(Object key) - возвращает value которое хранится в паре с указанным ключом, либо null, если в мапе нет парного
                  значения для данного ключа.

getOrDefault(Object key, V defaultValue) - возвращает значение, на которое ссылается указанный ключ, либо
                                           defaultValue, если в мапе нет пары для указанного ключа.
                                           Разница между этим методом и методом get(Object key): Если указанный ключ
                                           существует то оба метода вернут значение, связанное с данным ключом.
                                           Но если ключ не существует, метод get вернет null, а getOrDefault вернет
                                           значение которое указанное по умолчанию в качестве его параметра
                                           (defaultValue).

clear() - удаляет все из HashMap, после его применения мапа будет пустой.

isEmpty() - возвращает true если мапа пуста, либо false если не пуста.

containsKey(Object key) - возвращает true если в мапе имеется искомый ключ, и false если нет.

containsValue(Object value) - возвращает true если в мапе имеется один или несколько ключей сопоставленных с данным
                              значением.

replace(K key, V value) - заменяет запись (значение) для указанного ключа, только в случае если он ранее был связан с
                          каким либо значением. Возвращает предыдущее значение, связанное с указанным ключом, либо null
                          , если для ключа не было отображения.

replace(K key, V oldValue, V newValue) - заменяет запись для указанного ключа, только если данный ключ ранее был
                                         сопоставлен с указанным значением. Возвращает true, если значение было
                                         изменено.

remove(Object key) - удаляет пару по ключу, если таковая имеется в мапе. Возвращает value для ключа если оно имелось,
                     либо null, если такого значения не было.

remove(Object key, Object value) - удаляет конкретную пару, только в случае полного метча. Возвращает true если
                                   значение было успешно удалено.

*
======================================================================================================
4) КЛАСС LINKED-HASH-MAP

Class LinkedHashMap<K,V> - реализация хеш-таблицы и связанного списка для Interface Map с прогнозируемым порядком
итераций. Class LinkedHashMap расширяет Class HashMap и отличается от Class HashMap тем, что поддерживает двусвязный
список, который проходит через все его записи (элементы). Этот связанный список определяет порядок итераций, который
зачастую является порядком, в котором ключи были вставлены в Map (порядок вставки). К- тип поддерживаемых ключей.
V - тип сопоставленных/отображаемых значений.

Class LinkedHashMap:
- Содержит значения которые базируются на ключе.
- Содержит уникальные элементы.
- Может иметь один null ключ и несколько null значений.
- Несинхронизованный. Несколько потоков могут одновременно модифицировать обьект.
- Поддерживает порядок вставки.

Class LinkedHashMap может немного уступать в продуктивности родительскому Class HashMap, при этом время выполнения
операций add(), contains(), remove() остается константным - О(1)ю

Class LinkedHashMap нужно немного больше маста в памяти для сохранения элементов и их связей.

*
======================================================================================================
5) КЛАСС TREE-MAP

Class TreeMap<K,V> - реализация Interface NavigableMap на базе (сбалансированного) красно-черного дерева. Map
сортируется в соответствии с природным порядком его ключей либо с помощью компаратора, который предоставляется во
время создания Map, в зависимости от того, какой конструктор используется. Class TreeMap так-же может реализовывать
Interface SortedMap. K - тип поддерживаемых ключей. V - тип сопоставимых/отображаемых значений.

https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html

Определение, описание и сложность красно-черного дерева:

https://en.wikipedia.org/wiki/Red–black_tree

https://www.baeldung.com/cs/red-black-trees

Class TreeMap:

- содержит значения которые базируются на ключе.
- содержит только уникальные элементы.
- не может иметь null ключ, но может иметь несколько null значений.
- не синхронизирован. Несколько потоков могут одновременно модифицировать обьект.
- поддерживает порядок вставки по возрастанию.

Interface SortedMap<K,V> - Interface Map, который дополнительно обеспечивает полное упорядочивание своих ключей. Map
упорядочивается в соответствии к натуральному порядку его ключей либо с помощью компаратора, который предоставляется
во время создания SortedMap. K - тип поддерживаемых ключей. V - тип сопоставимых/отображаемых значений.

Interface NavigableMap<K,V> - Interface SortedMap, дополненный методами навигации, которые возвращают ближайшие
совпадения для заданных целей поиска. K - тип поддерживаемых ключей. V - тип сопоставимых/отображаемых значений.
*
======================================================================================================
6) ДОПОЛНИТЕЛЬНЫЕ МАТЕРИАЛЫ

Best Data Structure for Dictionaries
https://www.baeldung.com/cs/language-dictionary-data-structure

Java Map
https://jenkov.com/tutorials/java-collections/map.html

A Guide to Java HashMap
https://www.baeldung.com/java-hashmap

Iterate Over a Map in Java
https://www.baeldung.com/java-iterate-map

Sorting Java Map in Descending Order
https://www.baeldung.com/java-sort-map-descending

Difference Between Map and HashMap in Java
https://www.baeldung.com/java-map-vs-hashmap

A Guide to LinkedHashMap in Java
https://www.baeldung.com/java-linked-hashmap

A Guide to TreeMap in Java
https://www.baeldung.com/java-treemap

Java TreeMap vs HashMap
https://www.baeldung.com/java-treemap-vs-hashmap

Java SortedMap
https://jenkov.com/tutorials/java-collections/sortedmap.html

Java NavigableMap
https://jenkov.com/tutorials/java-collections/navigablemap.html

Time Complexity of Java Collections
https://www.baeldung.com/java-collections-complexity

Understanding Hash Tables
https://www.baeldung.com/cs/hash-tables

*
======================================================================================================