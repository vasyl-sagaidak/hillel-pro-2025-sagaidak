=======================================================================================================
ЛЯМБДА-ВЫРАЖЕНИЯ

Лямбда-выражения по существу представляют собой анонимный метод. Однако такой метод не выполняется сам по себе.
Взамен он используется для реализации метода, определенного функциональным интерфейсом. Таким образом, лямбда-выражение
приводит к форме анонимного класса. Лямбда-выражения так-же часто называют замыканиями.

Лямбда-выражения работают с интерфейсом, в котором есть только 1 абстрактный метод. Такие интерфейсы называют
функциональными интерфейсами, т.е. интерфейсами, пригодными для функционального программирования.

Функциональный интерфейс - это интерфейс, который содержит один, и только один абстрактный метод,
обычно устанавливающий предполагаемое назначение интерфейса. Соответственно функциональный интерфейс, как правило,
представляет одиночное действие. Например, стандартный интерфейс Runnable является функциональным интерфейсом,
поскольку в нем определен только один метод run(). Следовательно, run() определяет действие Runnable. Кроме того,
функциональный интерфейс задает целевой тип лямбда-выражения. Важно понимать, что лямбда-выражение может применяться
только в контексте, в котором указан его целевой тип. И еще один момент: функциональный интерфейс иногда называют
типом SAM, где SAM означает Single Abstract Method - единственный абстрактный метод.

Самый короткий вариант написания лямбда-выражения:
                                stud -> stud.avgGrade > 8.5

Более полный вариант написания лямбда-выражения (более читаемый):
                        (Student stud) -> {return stud.avgGrade > 8.5;}

1) В лямбда выражении оператор стрелка " -> " разделяет параметры метода и тело метода.

2) В лямбда выражении справа от оператора -> находится тело метода, которое было бы у метода соответствующего класса,
имплементировавшего наш интерфейс с единственным методом.

                    ( --- параметры метода --- ) -> { ------- тело метода -------;}

3) Можно использовать смешанный вариант написания лямбда-выражения:
Слева от оператора "стрелка" писать короткий вариант, справа полный. Или наоборот.

                            (Student stud) -> stud.avgGrade > 8.5
                                            либо
                             stud -> {return stud.avgGrade > 8.5;}

4) Если используется полный вариант написания для части справа от "стрелки" (для тела метода), то следует
в фигурных скобках использовать ключевое слово return и замыкающий знак ";".

5) Левая часть лямбда-выражения может быть написана в краткой форме, если метод интерфейса принимает только
1 параметр. Даже если метод интерфейса принимает 1 парамер, но в лямбда выражении вы хотите писать данный параметр
используя его тип данных, тогда уже вы должны писать левую часть лямбда выражения в скобках.

6) Если в правой части лямбда выражения вы пишете более отдного statement-a, то следует использовать его полный
вариант написания.

7) Если метод в функциональном интерфейсе не принимает никаких параметров, то слева от "стрелки" следует
использовать пустые скобки:

public class Test2 {
    static void def(I i) {
        System.out.println(i.abc());
    }

    public static void main(String[] args) {
        def(() -> 18);
    }
}

interface I {
    int abc ();
}

8) КАК МОЖНО ПИСАТЬ ЛЯМБДА-ВЫРАЖЕНИЯ:

def( () -> 5); //Если метод функционального интерфейса не принимает параметров.

def( (x) -> x.length() ); //Если в методе один параметр то слева можем брать, а можем не брать его в скобки.

def( (String x) -> x.length() ); //Если мы хотим указать в лямбде тип параметра то тогда слева берем его в скобки.

def( (x,y) -> x.length() ); //Если абстрактный метод принимает два параметра, то мы обязаны взять их слева в скобки,
def( (String x, String y) -> x.length() ); //независимо от того указываем мы типы или нет.

КАК НЕЛЬЗЯ ПИСАТЬ (CompilationError):

def( x -> {x.length();} ); //использовать в теле метода фигурные скобки но не использовать return

def( x -> {return x.length()} ); //не использовать в фигурных скобках замыкающий знак ; после return statement.

def( x,y -> x.length() ); //параметров абстрактного метода больше 1, и они не взяты в скобки в левой части.


Лямбда выражения могут писаться в параметрах метода (как было указано выше: см. интерфейс I), так и как отдельная
реализация функционального интерфейса через ссылку данного интерфейса, по типу как в случае анонимного класса:

interface StudentChecks {
    int checkStudent(Student s);
}

class Test {
    public static void main(String[] args) {
    StudentChecks sc = (Student s) -> {return s.length();}; // вот такой вариант записи
    }
}

СКОУП ПЕРЕМЕННЫХ ЛЯМБДА-ВЫРАЖЕНИЯ:
* Переменная задикларированная в левой части от -> является локальной и имеет область видимости исключительно
в пределах самого лямбда-выражения.
** Глобальные переменные доступны в лямбда-выражениях и их спокойно можно использовать в теле метода при условии
что они обьявлены как final, или же при условии что вы ее никогда не измените и она является effectively final.
*** Если у нас есть глобальная переменная с каким то именем, то переменная лямбда-выражения не может иметь то-же имя,
будет ошибка компиляции.

method( (int x, int y) -> {int x = 5; return 10;}  ); //нельзя обьявлять в теле лямбды переменную с тем же именем что
и у параметра на входе в метод. NOT OK.

method( (int x, int y) -> {x = 5; return 10;} ); //присваивать какое-то значение параметра можно. ОК.

method ( (int x, int y) -> {x2 = 5; return 10;} ); //Создавать новую локальную переменную в теле лямбды это ОК.

*
=======================================================================================================