package examples.generics.genericmethod;

public class GenMethDemo {

    /*
Вот синтаксис обобщенного метода:
                                    <type-param-list> return-type method-name (param-list) {}

Параметры типа обьявляются перед возвращаемым типом метода. Кроме того, обратите внимание на конструкцию
T extends Comparable<T>. Интерфейс Comparable обьявлен в пакете java.lang. Класс, реализующий Comparable,
определяет обьекты, которые можно упорядочивать.
Таким образом, требование верхней границы как Comparable гарантирует, что метод isIn() может использоваться
только с обьектами, которые обладают способностью участвовать в сравнениях. Интерфейс Comparable является
обобщенным, и его параметр типа указывает тип сравниваемых обьектов. (Вскоре вы увидите, как создавать
обобщенный интерфейс.) Далее обратите внимание, что тип V ограничен сверху типом Т. Соответственно тип V
должен быть либо тем же самым, что и тип Т, либо подклассом Т. Такое отношение гарантирует, что метод isIn()
можно вызвать только с аргументами, которые совместимы друг с другом. В данном случае метод определен как
статический, но обобщенные методы могут быть как статические так и не статические.
     */


     static <T extends Comparable<T>, V extends T> boolean isIn(T x, V[] v) {
        for (int i = 0; i < v.length; i++) {
            if (x.equals(v[i])) {
                return true;
            }
        }
        return false;
    }


    /*
Метод isIn() вызывается внутри main() с применением обычного синтаксиса вызова без необходимости указывать
аргументы типа. Дело в том, что типы аргументов распознаются автоматически, а типы T и V надлежащим образом
корректируются.
Хотя выведения типов будет достаточно для большинства вызовов обобщенных методов, при необходимости
аргумент типа можно указывать явно.

Скажем, вот как выглядит первый вызов isIn(),
когда указаны аргументы типов:
                                GenMethDemo.<Integer, Integer>isIn(2, nums) {...}

Конечно, в данном случае указание аргументов типов не дает какого-либо выигрыша. Кроме того, в JDK 8 выведение
типов было улучшено в том, что касается методов. В результате в настоящее время встречается меньше случаев,
когда требуются явные аргументы типов.


     */
    public static void main(String[] args) {
        Integer[] nums = {1, 2, 3 ,4, 5};
        if (isIn(2,nums)); {
            System.out.println("2 присутствует в nums");
        }
        if (!isIn(7, nums)) {
            System.out.println("7 не присутствует в nums");
        }
        System.out.println();

        String[] strs = {"one", "two", "three", "four", "five"};
        if (isIn("two", strs)) {
            System.out.println("two присутствует в strs");
        }
        if (!isIn("eleven", strs)) {
            System.out.println("eleven не присутствует в strs");
        }
    }

}
