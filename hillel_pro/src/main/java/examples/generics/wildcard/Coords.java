package examples.generics.wildcard;

/*
Обобщенный класс Coords, в котором хранится массив координат.
В классе Coords указан параметр типа, ограниченный TwoD, т.е любой массив, хранящийся в обьекте Coords,
будет содержать обьекты класса TwoD или одного из его подклассов.
 */
public class Coords<T extends TwoD> {
    T[] coords;

    Coords(T[] coords) {
        this.coords = coords;
    }
/*
Теперь предположим, что вы хотите написать метод, который отображает
координаты Х и У для каждого элемента в массиве coords объекта Coords.
Поскольку все типы объектов Coords имеют как минимум две координаты
(Х и У), это легко сделать с помощью подстановочного знака:
 */
    static void showXY(Coords<?> c) {
        System.out.println("Координаты Х У:");
        for (int i = 0; i < c.coords.length; i++) {
            System.out.println(c.coords[i].x + " " + c.coords[i].y);
            System.out.println();
        }
    }
    /*
Из-за того, что Coords является ограниченным обобщенным типом, применяющим TwoD в качестве верхней границы,
все объекты, которые можно использовать для создания объекта Coords, будут массивами элементов класса TwoD
или производных от него классов. Таким образом, метод showXY () способен отображать содержимое любого объекта Coords.

Но что, если вы хотите создать метод, отображающий координаты Х, У и Z объекта ThreeD или FourD?

Проблема в том, что не все объекты Coords будут иметь три координаты, т.к. объект Coords<TwoD>
располагает только Х и У. Как тогда написать метод, отображающий координаты Х, У и Z для объектов
Coords<ThreeD> и Coords<FourD>, и одновременно предотвратить применение этого метода с объектами Coords<TwoD>?

Ответ - воспользоваться ограниченным аргументом с подстановочными знаками.

В ограниченном аргументе с подстановочным знаком задается верхняя или нижняя граница для аргумента типа,
что позволяет сузить диапазон типов объектов, с которыми будет работать метод. Наиболее распространенным
ограничением является верхняя граница, создаваемая с помощью конструкции extends почти так же, как при
создании ограниченного типа. Используя ограниченный аргумент с подстановочным знаком, легко создать метод,
который отображает координаты Х, У и Z объекта Coords, если он действительно имеет указанные три координаты.
Например, следующий метод showXYZ ( ) выводит координаты Х, У и Z элементов, хранящихся в объ-
екте Coords, если эти элементы действительно относятся к типу ThreeD (или к типу, производному от ThreeD):
     */

    static void showXYZ(Coords<? extends ThreeD> c) {
        System.out.println("Координаты XУZ:");
       for (int i = 0; i < c.coords.length; i++) {
           System.out.println(c.coords[i].x + " " + c.coords[i].y + " " + c.coords[i].z);
       }
    }
/*
Обратите внимание, что к подстановочному знаку в объявлении параметра с добавлена конструкция extends.
Она указывает, что ? может соответствовать любому типу, если он является ThreeD или классом, производным
от ThreeD. Таким образом, конструкция extends устанавливает верхнюю границу того, чему может соответствовать
подстановочный знак. Из-за такой привязки метод showXYZ () можно вызывать со ссылками на объекты типа Coords<ThreeD>
или Coords<FourD>, но не со ссылкой на объект типа Coords<TwoD>. Попытка вызвать showXZY () со ссылкой на объект типа
Coords<TwoD> приводит к ошибке на этапе компиляции, что обеспечивает безопасность в отношении типов.
 */
    static void showAll(Coords<? extends FourD> c) {
        System.out.println("Координаты X У Z T:");
        for (int i = 0; i < c.coords.length; i++) {
            System.out.println(c.coords[i].x + " " +
                    c.coords[i].y + " " +
                    c.coords[i].z + " " +
                    c.coords[i].t);

        }
    }

/*
В общем случае для установления верхней границы аргумента с подстановочным знаком используйте
выражение следующего вида: <? extends superclass> ,
где superclass - имя класса, служащего верхней границей. Не забывайте что это включающая конструкция,
поскольку класс, формирующий верхнюю границу (т.е. указанный в superclass), также находится в пределах границ.

Вы также можете указать нижнюю границу аргумента с подстановочным знаком, добавив к объявлению
конструкцию super с таким общим видом: <? super subclass>

В данном случае допустимыми аргументами будут только классы, являющиеся суперклассами subclass.
Конструкция тоже включающая.
 */
}
