package examples.generics.raw_type;

/*
НИЗКОУРОВНЕВЫЙ ТИП (RAW TYPE)

Поскольку до 5й джавы поддержка дженериков отсутствовала, а джава славится своей поддержкой старого кода,
необходимо было обеспечить какой-то костыль для поддержки этого самого старого легаси кода.

Что-бы код до 5 версии мог работать с дженериками, а дженерик код имел возможность работы со старым кодом.

В плане обработки перехода к обобщениям Java разрешает использовать обобщенный класс без аргументов типов,
что создает НИЗКОУРОВНЕВЫЙ ТИП (RAW TYPE) для класса. Такой низкоуровневый тип совместим с легаси кодом.
Главный недостаток применения raw type связан с утратой безопасности в отношении типов, обеспечиваемой
дженериками.

Пример:
Gen raw = new Gen (Double.valueOf(98.6));

По существу оператор создает обьект Gen, тип Т которого заменяется на Object.

Использование RAW TYPE может стать причиной генерации исключений во время выполнения.

СЛЕДУЕТ ОГРАНИЧИВАТЬ ИСПОЛЬЗОВАНИЕ RAW TYPE СИТУАЦИЯМИ, когда нужно смешивать LEGACY код с более новым
обобщенным GENERIC кодом. Низкоуровневые RAW типы являются просто переходным средством, а не тем, что следует
применять в новом коде.
 */

import examples.generics.Gen;

public class RawDemo {
    public static void main(String[] args) {

        // Создать обьект Gen для типа Integer
        Gen<Integer> iOb = new Gen<Integer>(88);

        // Создать обьект Gen для типа String
        Gen<String> strOb = new Gen<String>("Generic test");

        // Создать низкоурованевый/raw type обьект Gen и предоставить ему значение Double.
        Gen raw = new Gen(Double.valueOf(98.6));

        //Явное приведение типов здесь обязательно, потому что тип неизвестен.
        double d = (Double) raw.getOb();
        System.out.println("Значение: " + d);


        // Использование RAW TYPE может стать причиной генерации исключений во время выполнения.
        // Следующие варианты выбросят исключения:

        // int i = (Integer) raw.getOb(); // ошибка во время выполнения

        // strOb = raw; //Нормально, но потенциально не правильно
        // String str = strOb.getOb(); // ошибка во время выполнения

        // raw = iOb; //Нормально, но потенциально не правильно
        // d = (Double) raw.getOb(); // ошибка во время выполнения

    }

}
