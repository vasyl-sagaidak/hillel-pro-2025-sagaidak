Урок 06 (Четверг - 09.01.2025)
Тема: Java Memory Management
======================================================================================================
Ключевые разделы:

1) ТИПЫ ДАННЫХ В JAVA И ИХ ОСОБЕННОСТИ
2) JAVA MEMORY MANAGEMENT
3) JAVA (JVM) MEMORY STRUCTURE
4) РАБОТА СБОРЩИКА МУСОРА
5) JAVA MEMORY MODEL
6) СБОРКА МУСОРА В JAVA
7) ФАЗЫ СБОРКИ МУСОРА В JAVA
8) СБОРЩИК МУСОРА (GARBAGE COLLECTOR, GC)
9) ТИПЫ СБОРЩИКОВ МУСОРА В JAVA

======================================================================================================
1) ТИПЫ ДАННЫХ В JAVA И ИХ ОСОБЕННОСТИ

В Stack у нас хранятся все примитивы, ссылки на обьекты, список вызова методов.
В Heap у нас хранятся все обьекты, примитивы которые являются частью обьектов (переменные-поля).

Примитивы (Primitives) – небольшие по обьему типы данных с известным заранее размером,
в основном для работы с числами, значения сохраняются в Stack напрямую.

Ссылочные (Reference) – для переменных этого типа, Stack сохраняет только ссылку на адрес ячейки
в памяти Heap где сохранен обьект относящийся к этой ссылке.

Существует 8 примитивных типов данных:

NAME:   |      SIZE:      |                                RANGE:                                    | DEFAULT:

byte    | 1 byte / 8-bit  |                             -128 to +127                                 | 0
char    | 2 byte / 16-bit |                              0 to 65535                                  | /u0000
short   | 2 byte / 16-bit |                          -32768 to +32767                                | 0
int     | 4 byte / 32-bit |          -2^31 to +2^31 -1 / -2_147_483_648 to +2_147_483_647            | 0
float   | 4 byte / 32-bit |                       6-7 digits after decimal                           | 0.0
long    | 8 byte / 64-bit | -2^63 to +2^63 -1 / -928_372_036_854_775_808 to +928_372_036_854_775_807 | 0
double  | 8 byte / 64-bit |                       15 digits after decimal                            | 0.0
boolean | 1 bit to 1 byte |                               false to true                              | false

Примитивный тип char имеет две формы: первую в виде графического изображения символа в одинарных кавычках
и вторую в виде '\ucode', согласно которому для каждого символа отводится два байта:
•	Первый байт содержит код управляющего символа или алфавита.
•	Второй байт соответствует спецификации символа в стандарте кода ASCII (Аски).

То-есть тип чар может иметь свое цифровое представление. Если обьявить переменную char a = 'a';
затем еще одну переменную int num и присвоить ей в качестве значения переменную а, int num = a; ,
то при выводе в консоль System.out.println(num); мы получим числовое значение 97, это потому, что char
у нас привязаны к таблице ASCII и под 97 номером в этой таблице находится буква 'a'.

*
======================================================================================================
2) JAVA MEMORY MANAGEMENT

Java Memory Management - процесс выделения памяти (allocation) для новых обьектов и удаления
(de-allocation) обьектов, которые не используются.

Основные концепции управления памятью:
- Cтруктура памяти JVM (Java Memory Structure)
- Работа сборщика мусора (GC)

Java автоматически управляет памятью посредством сборщика мусора (GC), и разработчику нет необходимости
реализовывать логику управления памятью в программе, которую он пишет.

Однако, сборщик мусора не гарантирует освобождение памяти/обьектов, на которые по прежнему есть ссылки.
Могут остаться ссылки на обьекты даже после их использования, что приводит к memory leakage либо сбою
в программе. JVM не может справиться со всеми ситуациями.
*
======================================================================================================
3) JAVA (JVM) MEMORY STRUCTURE

Java Memory Model описывает как потоки Java взаимодействуют через память.

JVM Memory Structure (структура памяти в JVM) имеет разные области, в которой находятся обьекты программ.
Это METHOD-AREA, HEAP-AREA, STACK-AREA, PC-REGISTERS, NATIVE-METHOD-STACK.

METHOD-AREA - логическая часть в HEAP, которая создается при запуске виртуальной машины.

Method-Area выделяется для данных методов, структур классов, данных полей конструктора, а так же для
интерфейсов и специальных методов в классе.

Method-Area хранит:
                   - имя суперкласса,
                   - имя интерфейса
                   - конструкторы.

Method-Area включает элементы характерные для каждого класса, включая поля, пулы констант, локальные данные
метода и.т.д, которые используются для инициализации обьектов и интерфейсов.


HEAP-AREA состоит из:
                        Heap-Memory - область данных времени выполнения, из которой выделяется память всем
                        экземплярам Java класса и массивов. Heap создается во время запуска JVM и может
                        динамически менять размер во время работы программы.

                        Non-Heap-Memory - создается при запуске JVM и хранит структуры для каждого класса,
                        такие как пул констант времени выполнения, данные полей и методов, а так-же код для
                        методов и конструкторов, интернованые строки.
                        Интернирование строк - механизм, в котором одинаковые литералы являются одним обьектом
                        в памяти.

                        Other-Memory - используется для хранения кода JVM, внутренней структуры JVM, данных и
                        загруженного кода Profiler агента и т.п.

Java Profiler - инструмент, который отслеживает конструкции и операции байт-кода JAVA на уровне JVM.
Эти конструкции кода и операции включают создание обьекта, итеративное исполнение (включая рекурсивные вызовы)
, выполнение методов, выполнение потоков и уборку мусора.

STACK-AREA:

Стек создается одновременно с созданием потока. Стек используется для хранения специфических для метода
значений, которые не являются долговечными и ссылаются на другие обьекты в Хипе.

Stack-frame - структура данных потока. Фрейм стека сохраняет частичные результаты, а данные так-же выполняют
динамическую компановку.

Каждый фрейм(кадр) содержит собственный массив локальных переменных (Local Variable Array, LVA), данные кадра
(Frame Data, FD) и стек операндов (Operand Stack, OS).

В потоке одновременно активен только один кадр - потоковый кадр.

Program Counter (PC) Registers - каждый созданный поток JVM имеет в себе регистр РС. Собственный указатель
или адрес возврата хранится в регистре РС. Он также включает расположение выполняемых инструкций JVM.

Native Method Stack - стек собственных/нативных методов, также известный как стек С, который написан на другом
языке программирования, не Java.

Нативный интерфейс Java (Java Native Interface, JNI) вызывает свой собственный стек. Этот тип памяти
выделяется потоку во время его создания. Продуктивность нативного стека зависит от операционной системы.
*
======================================================================================================
4) РАБОТА СБОРЩИКА МУСОРА

Сборка мусора - процесс высвобождения памяти, которую занимают обьекты, на которые ничто не ссылается.

HEAP - единственная часть памяти Java, где возможна сборка мусора.

Когда в Java запускается программа, обьектам выделяется память в HEAP.
Сборщик мусора старается сохранить как можно больше свободной рабочей памяти, он управляется JVM.
Соответственно, именно виртуальная машина JVM решает когда его запускать. Сборка мусора выполняется каждый
раз, когда JVM определяет низкую доступность ресурсов рабочей памяти.
JVM также учитывает запрос разработчика на сборку мусора, однако не всегда гарантируется,
что она выполнит данный запрос. Каждый обьект в Хипе на который нет ссылок, подходит для уборки сборщиком мусора.

Java запускает несколько потоков, все использующиеся в Heap обьекты доступны из Stack-Frame'ов этих
запущенных потоков.
Любой обьект, недоступный ниодному из потоков, считается лишенным ссылки и становится доступным для подтирания
сборщиком мусора.
*
======================================================================================================
5) JAVA MEMORY MODEL

Память Java состоит из Thread Stack, Heap и Metaspace.

Thread Stack (Стек потоков). Каждый поток будеи иметь собственный стек, то есть потоки не могут получить
доступ к потоку друг друга.

Локальные переменные сохраняются в Stack и ссылаются на обьекты в Heap, также в стеке хранятся значения
примитивных типов данных.

Heap (куча) - динамическая память. Обьекты, которые создаются во время выполнения Java-программы,
сохраняются в динамической памяти.

Ссылки на вновь сформированные обьекты сохраняются в памяти Stack. За динамическим выделением памяти следит
Heap.

Обьект получает место в хипе, когда используется ключевое слово new, но ссылка на тот самый обьект что уже существует
в стеке. Память Heap значительно больше по размерам чем Stack, но и медленней.

Metaspace (метапространство) - сохраняет медаданные про классы, методы. Например, какие методы компилируются
в байт-код.

Стек для статических переменных. Сохраняет примитивные статические переменные ссылки на статический обьект,
который указывает на фактический обьект, который сохраняется в Heap.

Переменные в metaspace являются постоянными в течении жизненного цикла программы, потому соответствующий обьект в Хипе
никогда не будет удален сборщиком мусора.

Все классы и потоки в программе Java имеют доступ к metaspace.

*
======================================================================================================
6) СБОРКА МУСОРА В JAVA

Cборка мусора (Garbage Collection) - процесс освобождения памяти, которая не используется во время исполнения.
Способ уничтожения обьектов, которые не используются.

В Java динамическое выделение памяти для обьектов достигается с помощью ключевого слова new. Как только обьект
создан, он использует некоторую память, и она остается выделенной под него до тех пор, пока имеются ссылки
использования обьекта. Когда обьект не имеет ссылок, подразумевается что он не нужен, и память, занятая обьектом,
может быть освобождена.

Процесс сборки мусора в Java происходит автоматически. У разработчика нет явной потребности уничтожать обьект.

Преимущества сборки мусора:
- делает память эффективной, поскольку сборщик мусора удаляет обьекты на которые больше нет ссылок.
- процесс выполняется сборщиком мусора (частью JVM) автоматически, поэтому разработчику не требуется применять
дополнительные усилия.

Когда программы запускаются на JVM, обьекты создаются в памяти Heap, которая есть частью памяти,
выделенной для программы. Heap используется Java Runtime для выделения памяти под обьекты и JRE классы.

Создание нового обьекта происходет в Heap, и там-же работает сборщик мусора (garbage collector), освобождая память от
обьектов на которые нет ссылок. Любой обьект созданный в Heap, имеет глобальный доступ и на него могут ссылаться
с любой части программы. В течении жизни программы Java возникают и удаляются новые обьекты.

Heap память состоит из типов обьектов:
- Живые - обьекты которые используются и имеют ссылки.
- Мертвые - обьекты которые не используются и на них больше нет ссылок.
*
======================================================================================================
7) ФАЗЫ СБОРКИ МУСОРА В JAVA

1) Маркировать (Mark) обьекты как живые.
2) Очистить (Sweep) мертвые обьекты.
3) Уплотнить (Compact) обьекты которые остались в памяти.

На фазе маркировки GC (Garbage Collector) идентифицирует все активные обьекты памяти, пересматривая граф обьектов.
Когда GC навещает обьект, он помечает его как доступный (живой). Все недоступные обьекты являются мусором
и считаются кандидатами на последующее удаление.

После фазы маркировки есть пространство памяти занятое живыми и мертвыми обьектами.

Мертвые обьекты, которые были удалены, не обязательно могли находиться рядом, таким образом мы получим
фрагментированный блок памяти.

Память можно уплотнить после того, как сборщик мусора удалит мертвые обьекты, для того, что бы оставшиеся
обьекты находились в непосредственном блоке вначале Heap.

Процесс уплотнения облегчает последовательное выделение памяти новым обьектам.
*
======================================================================================================
8) СБОРЩИК МУСОРА (GARBAGE COLLECTOR, GC)

Сборщик мусора автоматически управляет запросами программы на динамическое выделение памяти.

Операции по управлению памятью:
- выделение и возвращение памяти операционной системе;
- раздавание этой памяти программе по мере ее запросов;
- определение, какие части этой памяти все еще используются программой;
- возобновление памяти, которая не используется, для повторного использования программой;

Сборщик мусора Java реализует стратегию сборки мусора по поколениям, которая классифицирует обьекты по возрасту.

Молодое поколение (Young Generation):

- Пространство Эдема (Eden space) - тут стартуют новые обьекты, им выделяется начальная память.
- Пространство выживания (Survivor space) - сюда перемещаются все выживышие обьекты из Эдема после выполнения
одного цикла сборки мусора.

Когда обьекты собираются сборщиком мусора с YOUNG GENERATION, это НЕЗНАЧИТЕЛЬНОЕ СОБЫТИЕ сборки мусора.

Когда EDEN SPACE заполняется обьектами, ВЫПОЛНЯЕТСЯ НЕЗНАЧИТЕЛЬНОЕ СОБЫТИЕ. Все мертвые обьекты удаляются,
а все живые обьекты перемещаются в одно из SURVIVOR SPACES.

НЕЗНАЧИТЕЛЬНОЕ СОБЫТИЕ так же проверяет обьекты в области выживания и перемещает их в другую область выживания.

СТАРОЕ ИЛИ ПОСТОЯННОЕ ПОКОЛЕНИЕ (OLD or TENURED GENERATION). Тут хранятся долгоживущие обьекты. Когда обьекты
сохраняются в young generation, устанавливается порог возраста обьекта, и когда достигается этот порог, обьект
перемещается в старое поколение.

Когда обьект удаляется сборщиком мусора из старого поколения, это является ОСНОВНЫМ СОБЫТИЕМ сборки мусора.

ПОСТОЯННОЕ ПОКОЛЕНИЕ (Permanent Generation). Метаданные, такие как классы и методы, сохраняются в постоянном
поколении. Оно заполняется JVM во время выполнения на основании классов что используются программой.

Классы, которые не используются, могут быть удалены сборщиком мусора из постоянного поколения.

С Java 8 Permanent Generation (PermGen) изменено на METASPACE. PermGen находится в Heap, Metaspace же не является
частью Heap памяти. Большинство распределений метаданных класса выделяются за пределами собственной (native)
памяти.

PermGen имеет фиксированный размер, а Metaspace автоматически увеличивает свой размер, что позволяет избежать
java.lang.OutOfMemoryError.

Metaspace (Метапространство) содержит метаданные про классы, методы. Например, какие методы компилируются в
байт-код. Metaspace хранит примитивные статические переменные ссылки на статический обьект, который указывает
на фактический обьект, который хранится в Heap.

         | Survivor Space |
|  EDEN  |   S0  |   S1   |     TENURED    |      PERMANENT       |
|    Young Generation     | Old Generation | Permanent Generation |

*
======================================================================================================
9) ТИПЫ СБОРЩИКОВ МУСОРА В JAVA

Серийный (последовательный) сборщик (SERIAL COLLECTOR).
Параллельный сборщик (PARALLEL COLLECTOR).
GARBAGE-FIRST (G1) сборщик мусора.
Сборщик мусора Z (THE Z GARBAGE COLLECTOR).

Состав и определение типов сборщиков мусора может отличаться в меру развития Java.

СЕРИЙНЫЙ СБОРЩИК (SERIAL COLLECTOR) использует один поток для выполнения всей работы для сбора мусора, что делает
его относительно эффективным, поскольку между потоками нет дополнительных затрат на связь.

Он лучше всего подходит для однопроцессорных машин, поскольку не может использовать преимущества многопро-
цессорного оборудования, хотя может быть полезным на многопроцессорных системах приложений с небольшими
наборами данных (приблизительно 100 МБ).

ПАРАЛЛЕЛЬНЫЙ СБОРЩИК (PARALLEL COLLECTOR) предназначен для приложений с наборами данных среднего и большого
обьемов, которые выполняются на многопроцессорном либо многопоточном оборудовании.

GARBAGE-FIRST (G1) СБОРЩИК мусора предназначен для масштабирования от небольших до больших многопроцессорных машин
с большим обьемом памяти.

Обеспечивает возможность достижения целевой паузы с высокой вероятностью при достижении високой пропускной
способности. G1 выбирается по дефолту в большинстве конфигураций оборудования и операционных систем.

СБОРЩИК МУСОРА Z (THE Z GARBAGE COLLECTOR, ZGC) - сборщик мусора который масштабируется с малой задержкой.
ZGC выполняет всю работу одновременно не останавливая выполнения потоков программы.

ZGC обеспечивает максимальное время паузы в несколько миллисекунд за счет некоторой пропускной способности.

Как правильно выбирать сборщик мусора (GC)???

Если ваша программа не имеет жестких требований ко времени паузі, вам следует просто запустить свою программу
и позволить JVM выбрать правильный сборщик.

Рекомендации для выбора GC:

Последовательный - если программа имеет небольшой набор данных (приблизительно до 100 МБ) и/или будет выполняться
на одном процессоре без требований к паузе.

Параллельный - если пиковая продуктивность программы является приоритетом и нет требований ко времени паузы или
допустимы паузы длительностью в секунду или дольше.

G1 - если время отклика важнее общей пропускной способности, а паузы для сборки мусора должны быть короче
одной секунды.

ZGC - если время отклика имеет найвысший приоритет и/или вы используете очень большой HEAP.
*
======================================================================================================