Урок 19 (ЧЕТВЕРГ - 06.03.2025)
Тема: АЛГОРИТМЫ СОРТИРОВКИ
======================================================================================================
Ключевые разделы:

1) ПОНЯТИЕ И ХАРАКТЕРИСТИКИ АЛГОРИТМА
2) ПРИМЕР АЛГОРИТМА
3) СЛОЖНОСТЬ АЛГОРИТМА ПО ВРЕМЕНИ И ПРОСТРАНСТВУ
4) НЕКОТОРЫЕ ПРИМЕРЫ АЛГОРИТМОВ
5) АЛГОРИТМЫ СОРТИРОВКИ (Ч1)
6) АЛГОРИТМЫ СОРТИРОВКИ (Ч2)
7) АЛГОРИТМЫ ПОИСКА
8) ДОПОЛНИТЕЛЬНЫЕ МАТЕРИАЛЫ

======================================================================================================
1) ПОНЯТИЕ И ХАРАКТЕРИСТИКИ АЛГОРИТМА

Алгоритм в программировании – это набор инструкций или процедур, выполняемых для решения определенной
задачи или достижения определенной цели. Алгоритмы служат основой для написания программ и позволяют
решать различные задачи.

Характеристики алгоритма включают в себя:

- Корректность: Алгоритм должен решать поставленную задачу правильно и точно по всем возможным условиям.
- Временная сложность: это измерение времени, необходимое для выполнения алгоритма в зависимости от объ-
ема входных данных. Она определяется количеством операций, которые необходимо выполнить для завершения
алгоритма.
- Простота: Алгоритм должен быть прост для понимания и реализации.
- Производительность: Определяется объемом ресурсов, таких как память или вычислительная мощность,
которые используют алгоритм для выполнения своей работы.
- Масштабируемость: Алгоритм должен эффективно работать даже при увеличении размера входных данных.
- Расширяемость: Это способность алгоритма работать с разными типами данных и в разных условиях.
- Устойчивость к ошибкам: Алгоритм должен быть устойчив к ошибкам и непредсказуемым ситуациям.

Виды алгоритмов

 1. СОРТИРОВКА – это процесс упорядочения элементов в массиве или списке по определенному критерию,
 такому как рост или убывание.

Пример:

Сортировка пузырьком: это простой алгоритм сортировки, где сравниваются соседние элементы и если они
находятся в неправильном порядке, они обмениваются.
Быстрая сортировка: эффективный алгоритм сортировки, использующий стратегию "разделяй и властвуй".
Он выбирает один элемент списка как опорный и разбивает остальные элементы на две группы: меньше
опорного элемента и больше опорного элемента.
Сортировка слиянием: алгоритм сортировки, использующий стратегию "разделяй и властвуй", разделяя
массив на половины, сортируя их отдельно, а затем сливая их вместе.

 2. ПОИСК – это нахождение определенного элемента в массиве или списке.

Пример:

Бинарный поиск: алгоритм поиска, работающий для упорядоченного списка элементов. Он сравнивает
целевой элемент с элементом внутри списка и исключает половину, в которой целевой элемент не
может присутствовать.

Линейный поиск: простой алгоритм поиска, проверяющий каждый элемент в списке последовательно до
нахождения искомого элемента или до конца списка.

 3. РЕКУРСИЯ – это техника, при которой функция вызывает саму себя для решения проблемы меньших
 размеров.

Пример:

Факториал: классический пример рекурсивной функции, вычисляющей факториал числа. Факториал числа
n (обозначается как n!) – это произведение всех натуральных чисел от 1 до n.
Сумма элементов массива: функция, рекурсивно вычисляющая сумму всех элементов в массиве.

 4. ГРАФЫ – это структуры данных, включающие вершины и ребра, соединяющие эти вершины. Алгоритмы
 работы с графами используются для решения задач, связанных с сетями, путями и связями между объектами.

Пример:

Поиск в ширину (BFS): алгоритм поиска в графе, начинающий с определенной вершины и переходящий ко всем
соседним вершинам перед тем, как двигаться дальше вглубь графа.
Поиск в глубину (DFS): алгоритм поиска в графе, начинающий с определенной вершины и двигающийся вглубь
графа настолько, насколько это возможно, прежде чем возвращаться назад.

*
======================================================================================================
2) ПРИМЕР АЛГОРИТМА

Алгоритм Эвклида для нахождения Наибольшего Общего Делителя (НОД)

Алгоритм Эвклида - это метод нахождения крупнейшего общего делителя (НОД) двух целых чисел.
Он базируется на простой идее рекурсивного деления одного числа на другое и замещении его остатком,
пока не будет достигнут нулевой остаток. Когда одно из чисел становится нулем, то второе число и будет НОД.

Характеристики алгоритма:

Эффективность Алгоритм Эвклида очень эффективен для нахождения НОД. Временная сложность алгоритма зависит
от величины входных чисел, но в среднем она составляет O(log(min(M,N))), где M и N – входные числа.
Простота: Алгоритм Эвклида прост в реализации, и его логика проста и понятна.
Минимальное использование памяти: Этот алгоритм требует минимального объема памяти, поскольку он использует
только константное количество переменных для хранения промежуточных результатов.
Алгоритм Эвклида широко используется в реальной жизни.

Криптография: используется для нахождения НОД в криптографических алгоритмах, таких как RSA.
Математика: Используется в задачах теории чисел, где следует найти НОД двух чисел.
Алгоритм расчета контрольной суммы: используется для нахождения контрольных сумм в различных протоколах и
алгоритмах проверки целостности данных.

public class EuclideanAlgorithm {

    // Метод для знаходження НЗД двох чисел
    public static int findGCD(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }

    public static void main(String[] args) {
        int m = 32;
        int n = 24;
        int gcd = findGCD(m, n);
        System.out.println("Найбільший загальний дільник для " + m + " і " + n + " = " + gcd);
    }
}

*
======================================================================================================
3) СЛОЖНОСТЬ АЛГОРИТМА ПО ВРЕМЕНИ И ПРОСТРАНСТВУ

Сложность алгоритмов может быть оценена по времени выполнения и требуемому пространству памяти. Эти два
аспекта являются ключевыми для оценки эффективности алгоритмов.

Временная сложность Это количество времени, необходимого для выполнения алгоритма в зависимости от объема
входных данных. Временная сложность измеряется количеством операций, выполняемых алгоритмом. Обычно она
выражается в виде "Big-O Notation" (например, O(1), O(log n), O(n), O(n log n), O(n^2) и т.п.),
где n - размер входных данных.
Пространственная сложность: Это объем памяти, который необходим для выполнения алгоритма, также в
зависимости от объема входных данных. Пространственная сложность измеряется количеством памяти, используемой
для хранения данных или дополнительных структур данных, созданных алгоритмом.

Big-O Notation

"Big-O" – это формальный способ выражения сложности алгоритма в терминах верхнего предела. Она указывает,
как временная сложность или использование ресурсов изменяются с ростом размера входных данных.

Примеры Big O

O(1) – константное время, независимо от размера данных.
O(log N) – логарифмическое время, растет медленно при увеличении данных.
O(N) – линейное время, растет пропорционально размеру данных.
O(N log N) – линейно-логарифмическое время, часто возникающее в эффективных сортировках.
O(N^2) – квадратичное время, возрастает квадратично с увеличением данных.
O(2^N) – экспоненциальное время, быстро возрастающее с увеличением данных.

Для эффективной оценки алгоритмов важно сбалансировать оба аспекта сложности. Например, хотя алгоритм может
быть быстрым (имеющим низкую временную сложность), он может потребовать большого количества памяти (имеет
высокую пространственную сложность), что может быть неприемлемым в некоторых областях применения, особенно на
устройствах с ограниченными ресурсами. Поэтому для оценки алгоритмов важно учитывать оба аспекта и выбирать
алгоритмы, оптимальные по обоим показателям для конкретной задачи или среды.

*
======================================================================================================
4) НЕКОТОРЫЕ ПРИМЕРЫ АЛГОРИТМОВ

Рассмотрим пример алгоритма сортировки массива чисел методом "пузырчатой сортировки" и оценим его сложность
по времени и пространству.

Описание алгоритма:
Повторяем итерацию по массиву, сравнивая каждую пару соседних элементов.
Если порядок элементов неверен (например, текущий элемент больше следующего), меняем их местами.
Продолжаем этот процесс, пока весь массив не будет отсортирован.

Сложность по времени:
В самом худшем случае: O(n^2), где n - количество элементов в массиве. В самом худшем случае этот алгоритм
выполняет n^2 сравнений и обменов.
В среднем случае: O(n^2).
В лучшем случае (когда массив уже отсортирован): O(n), но все равно нужно пройтись по всему массиву, чтобы
убедиться, что он отсортирован.

Сложность по пространству:
Пространственная сложность этого алгоритма – O(1), то есть она не зависит от размера входных данных,
поскольку в алгоритме не используется дополнительная память, кроме уже выделенной для массива.

import java.util.Arrays;

public class BubbleSort {
    public static void main(String[] args) {
        int[] array = {64, 34, 25, 12, 22, 11, 90};

        // Виклик методу сортування бульбашкою
        bubbleSort(array);

        // Виведення відсортованого масиву
        System.out.println("Відсортований масив: " + Arrays.toString(array));
    }

    // Метод сортування бульбашкою
    static void bubbleSort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                // Порівнюємо пари сусідніх елементів
                if (arr[j] > arr[j + 1]) {
                    // Міняємо їх місцями, якщо порядок неправильний
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }
}

Результат:

Відсортований масив: [11, 12, 22, 25, 34, 64, 90]

Этот алгоритм прост для реализации, но не является наиболее эффективным для больших массивов, поскольку ему
требовалось много сравнений и обменов. Также важно учитывать, что для больших объемов данных другие алгоритмы
сортировки могут быть более эффективными с точки зрения временной сложности.

Рассмотрим алгоритм построения фибоначной последовательности рекурсивным способом и оценим его пространственную
сложность.

Пример: Рекурсивное построение Фибоначевой последовательности

Описание алгоритма:
Если n меньше или равно 1, возвращаем n.
Если n больше 1, рекурсивно вызываем функцию для вычисления фибоначевого числа (n-1) и (n-2).
Суммируем результаты предыдущих двух вызовов.
Сложность по времени:
В самом худшем случае: O(2^n), поскольку каждый вызов функции порождает два дополнительных вызова, и так далее.
Это приводит к экспоненциальному росту времени выполнения с увеличением значения n.

Сложность по пространству:
Пространственная сложность этого алгоритма зависит от количества рекурсивных вызовов, совершаемых в течение
выполнения. В нашем случае, для каждого вызова функции создается новый стек вызовов, занимающий пространство
памяти. Таким образом, пространственная сложность будет O(n), где n – глубина рекурсии, то есть количество
рекурсивных вызовов.

Пример:

public class FibonacciSequence {
    public static void main(String[] args) {
        int n = 10;
        for (int i = 0; i < n; i++) {
            System.out.print(fibonacci(i) + " ");
        }
    }

    // Рекурсивна функція для обчислення фібоначчівого числа
    static int fibonacci(int n) {
        if (n <= 1) {
            return n;
        }
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}

Результат:

0 1 1 2 3 5 8 13 21 34

Этот алгоритм имеет экспоненциальную сложность по времени и линейную по пространству, что делает его
неэффективным для больших значений n. Рекурсивный подход к построению фибоначной последовательности
может привести к переполнению стека вызовов (stack overflow) при больших значениях n. Поэтому для
больших значений лучше использовать итеративные или динамические подходы.

*
======================================================================================================
5) АЛГОРИТМЫ СОРТИРОВКИ (Ч1)

Алгоритмы сортировки – это специальные методы или процедуры, которые используются для организации элементов
в упорядоченный порядок. Эти алгоритмы играют важную роль в области программирования и компьютерных наук,
поскольку они позволяют эффективно обрабатывать и анализировать большие объемы данных.

Ниже приведены несколько основных алгоритмов сортировки:

Сортировка пузырем (Bubble Sort): Это простой алгоритм сортировки, проходящий по массиву несколько раз и
сравнивающий соседние элементы, перемещая больший элемент домой. Этот процесс повторяется, пока весь массив
не будет упорядочен.

Сортировка вставками: Этот алгоритм постепенно строит упорядоченную последовательность, продвигая каждый
следующий элемент в соответствующее место в упорядоченной части массива.

Сортировка по выбору (Selection Sort): Алгоритм выбирает наименьший элемент из неупорядоченной части
массива и обменивает его с первым элементом. Затем он выбирает следующий малейший элемент и обменивает
его со вторым элементом, и так далее.

Быстрая сортировка (Quick Sort): Это эффективный алгоритм сортировки, использующий стратегию "разделяй
и властвуй". Он выбирает элемент-сопротивление, разбивает массив на две части так, чтобы элементы меньше
опорного находились слева от него, а большие - справа. Затем алгоритм рекурсивно применяется к обоим
подмассивам.

Сортировка слиянием (Merge Sort) Этот алгоритм разбивает массив на две половины, сортирует каждую из
них рекурсивно, а затем объединяет их, слить массивы упорядоченными частями.

Разберем каждый алгоритм более подробно

=====================================
СОРТИРОВКА ПУЗЫРЬКОМ (Bubble Sort):
=====================================

Описание:
Этот алгоритм проходит по массиву несколько раз, сравнивая каждую пару соседних элементов и, при
необходимости, обменивает их местами. Повторяет этот процесс, пока весь массив не будет упорядочен.

Сложность по времени:
В самом худшем случае: O(n^2), где n - количество элементов в массиве.
В среднем случае: O(n^2).
В лучшем случае: O(n), когда массив уже отсортирован.

Сложность по пространству:
Пространственная сложность: O(1) не требуется дополнительной памяти, поскольку обмен происходит
без использования дополнительных структур данных.

Пример:

public class BubbleSort {
    public static void bubbleSort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n-1; i++) {
            for (int j = 0; j < n-i-1; j++) {
                if (arr[j] > arr[j+1]) {
                    // Обмін елементів
                    int temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                }
            }
        }
    }

    public static void main(String[] args) {
        int[] arr = {64, 34, 25, 12, 22, 11, 90};
        System.out.println("Масив перед сортуванням: " + Arrays.toString(arr));
        bubbleSort(arr);
        System.out.println("Масив після сортування: " + Arrays.toString(arr));
    }
}

Результат:
Масив перед сортуванням: [64, 34, 25, 12, 22, 11, 90]
Масив після сортування: [11, 12, 22, 25, 34, 64, 90]

Этот алгоритм прост в реализации, но не является наиболее эффективным для больших массивов из-за
квадратичной сложности по времени.

=====================================
СОРТИРОВКА ВСТАВКОЙ (Insertion Sort):
=====================================

Описание:
Этот метод равномерно строит упорядоченную последовательность, продвигая каждый последующий элемент
в подходящее место в упорядоченной части массива.

Сложность по времени:
В самом худшем случае: O(n^2), где n - количество элементов в массиве.
В среднем случае: O(n^2).
В лучшем случае: O(n), когда массив уже отсортирован.

Сложность по пространству:
Пространственная сложность: O(1) не требуется дополнительной памяти, поскольку сортировка происходит
без использования дополнительных структур данных.

Пример:

public class InsertionSort {
    public static void insertionSort(int[] arr) {
        int n = arr.length;
        for (int i = 1; i < n; ++i) {
            int key = arr[i];
            int j = i - 1;

            // Переміщення елементів масиву, які більше за key, на один вперед
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j = j - 1;
            }
            arr[j + 1] = key;
        }
    }

    public static void main(String[] args) {
        int[] arr = {64, 34, 25, 12, 22, 11, 90};
        System.out.println("Масив перед сортуванням: " + Arrays.toString(arr));
        insertionSort(arr);
        System.out.println("Масив після сортування: " + Arrays.toString(arr));
    }
}

Результат:
Масив перед сортуванням: [64, 34, 25, 12, 22, 11, 90]
Масив після сортування: [11, 12, 22, 25, 34, 64, 90]

Сортировка вставками эффективна для небольших массивов и почти отсортированных данных. Она проста в
реализации и имеет низкую пространственную сложность.

*
======================================================================================================
6) АЛГОРИТМЫ СОРТИРОВКИ (Ч2)

=====================================
СОРТИРОВКА ВЫБОРОМ (Selection Sort):
=====================================

Описание:
Сортировка выбором выбирает наименьший (или наибольший, в зависимости от порядка сортировки) элемент
из неупорядоченной части массива и обменивает его с первым элементом.
Затем алгоритм выбирает следующий наименьший элемент и обменивает его со вторым элементом, и так далее,
пока не будет сформирована упорядоченная последовательность.

Сложность по времени:
В самом худшем случае: O(n^2), где n - количество элементов в массиве.
В среднем случае: O(n^2).
В лучшем случае: O(n^2), поскольку даже если перед сортировкой массив уже отсортирован, алгоритм все
равно выполнит квадратичное количество сравнений и обменов.

Сложность по пространству:
Пространственная сложность: O(1), поскольку сортировка по выбору использует только константное
количество дополнительной памяти.

Пример:

import java.util.Arrays;

public class SelectionSort {
    public static void selectionSort(int[] arr) {
        int n = arr.length;

        for (int i = 0; i < n - 1; i++) {
            int minIndex = i;
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIndex]) {
                    minIndex = j;
                }
            }
            // Обмін поточного елементу з мінімальним елементом
            int temp = arr[minIndex];
            arr[minIndex] = arr[i];
            arr[i] = temp;
        }
    }

    public static void main(String[] args) {
        int[] arr = {64, 25, 12, 22, 11};
        System.out.println("Масив перед сортуванням: " + Arrays.toString(arr));
        selectionSort(arr);
        System.out.println("Масив після сортування: " + Arrays.toString(arr));
    }
}

Результат:
Масив перед сортуванням: [64, 25, 12, 22, 11]
Масив після сортування: [11, 12, 22, 25, 64]

Сортировка выбором проста и эффективна для небольших массивов, но не является самой эффективной
для больших объемов данных из-за своей квадратичной временной сложности.

=================================
БЫСТРАЯ СОРТИРОВКА (Quick Sort):
=================================

Описание:
Быстрая сортировка является эффективным алгоритмом, использующим стратегию "разделяй и властвуй".
Алгоритм выбирает элемент-сопротивление (pivot), разбивает массив на две части так, чтобы элементы
меньше опорного находились слева от него, а большие - справа.
Затем алгоритм рекурсивно применяется к обоим подмассивам.

Сложность по времени:
В самом худшем случае: O(n^2), где n - количество элементов в массиве. Это может произойти,
когда опорный элемент выбирается таким образом, что каждый другой элемент представляет собой
максимум или минимум массива.
В среднем случае: O(n log n), что делает его одним из самых быстрых алгоритмов сортировки.
В лучшем случае: O(n log n), когда каждый разрез массива делается пополам, и рекурсивные вызовы
совершаются пропорционально log n.

Сложность по пространству:
Пространственная сложность: O(log n), поскольку рекурсивные вызовы нуждаются в дополнительной памяти
для стека вызовов. Больше памяти будет использовано в случае, когда массив полностью упорядочен или
обратно упорядочен, что может привести к глубокому стеку вызовов.

Пример:

import java.util.Arrays;

public class QuickSort {
    public static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            int pivotIndex = partition(arr, low, high);
            quickSort(arr, low, pivotIndex - 1);
            quickSort(arr, pivotIndex + 1, high);
        }
    }

    public static int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;

        for (int j = low; j < high; j++) {
            if (arr[j] < pivot) {
                i++;
                // Обмін елементів
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }

        // Обмін pivot з елементом, що розташований після всіх менших за pivot
        int temp = arr[i + 1];
        arr[i + 1] = arr[high];
        arr[high] = temp;

        return i + 1;
    }

    public static void main(String[] args) {
        int[] arr = {64, 25, 12, 22, 11};
        System.out.println("Масив перед сортуванням: " + Arrays.toString(arr));
        quickSort(arr, 0, arr.length - 1);
        System.out.println("Масив після сортування: " + Arrays.toString(arr));
    }
}

Результат:
Масив перед сортуванням: [64, 25, 12, 22, 11]
Масив після сортування: [11, 12, 22, 25, 64]

Быстрая сортировка является одним из наиболее эффективных алгоритмов сортировки по времени в
среднем случае.

==================================
СОРТИРОВКА СЛИЯНИЕМ (Merge Sort):
==================================

Описание:
Сортировка слиянием – это алгоритм сортировки, который базируется на принципе "разделяй и властвуй".
Процесс делается из-за рекурсивного разбора массива на половины, пока не будет достигнуто базовое
условие. Каждая половина массива сортируется отдельно, затем объединяется с другой отсортированной
половиной с помощью процесса слияния. Слияние состоит в сравнении элементов двух отсортированных
массивов и их объединении в единый отсортированный массив.

Сложность по времени:
Все случаи: O(n log n), где n – количество элементов в массиве.

Сложность по пространству:
Пространственная сложность: O(n), где n – количество элементов в массиве, поскольку для слияния
необходимо дополнительное пространство для временного хранения данных во время рекурсивных вызовов.

Пример:

import java.util.Arrays;

public class MergeSort {
    public static void main(String[] args) {
        int[] arr = {12, 11, 13, 5, 6, 7};
        System.out.println("Вхідний масив: " + Arrays.toString(arr));

        mergeSort(arr, 0, arr.length - 1);

        System.out.println("Відсортований масив: " + Arrays.toString(arr));
    }

    public static void mergeSort(int[] arr, int left, int right) {
        if (left < right) {
            int mid = (left + right) / 2;

            // Рекурсивно сортуємо ліву і праву половини
            mergeSort(arr, left, mid);
            mergeSort(arr, mid + 1, right);

            // Зливаємо відсортовані половини
            merge(arr, left, mid, right);
        }
    }

    public static void merge(int[] arr, int left, int mid, int right) {
        int n1 = mid - left + 1;
        int n2 = right - mid;

        // Створюємо тимчасові підмасиви
        int[] L = new int[n1];
        int[] R = new int[n2];

        // Копіюємо дані в тимчасові підмасиви
        for (int i = 0; i < n1; ++i)
            L[i] = arr[left + i];
        for (int j = 0; j < n2; ++j)
            R[j] = arr[mid + 1 + j];

        // Зливаємо тимчасові підмасиви
        int i = 0, j = 0;
        int k = left;
        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) {
                arr[k] = L[i];
                i++;
            } else {
                arr[k] = R[j];
                j++;
            }
            k++;
        }

        // Копіюємо залишки L[], якщо такі є
        while (i < n1) {
            arr[k] = L[i];
            i++;
            k++;
        }

        // Копіюємо залишки R[], якщо такі є
        while (j < n2) {
            arr[k] = R[j];
            j++;
            k++;
        }
    }
}

Результат:
Вхідний масив: [12, 11, 13, 5, 6, 7]
Відсортований масив: [5, 6, 7, 11, 12, 13]

Сортировка слиянием – эффективный алгоритм с временной сложностью O(n log n), делающий его отличным
выбором для сортировки больших массивов данных.

*
======================================================================================================
7) АЛГОРИТМЫ ПОИСКА

Алгоритмы поиска – это методы, которые используются для поиска конкретного элемента или шаблона данных
в коллекции. Они могут использоваться в различных областях информатики, таких как поиск в базах данных,
алгоритмическая графика, обработка текста и т.д. Вот краткое описание некоторых алгоритмов поиска:

ЛИНЕЙНЫЙ ПОИСК (Linear Search):
Простой алгоритм, проверяющий каждый элемент последовательно от начала до конца.
Имеет временную сложность O(n), где n – количество элементов в коллекции.
БИНАРНЫЙ ПОИСК (Binary Search):
Эффективный алгоритм для упорядоченных коллекций.
Разбивает коллекцию пополам и ищет в половине.
Имеет временную сложность O(log n), где n – количество элементов в упорядоченной коллекции.
ПОИСК С ИСПОЛЬЗОВАНИЕМ ХЕШ-ТАБЛИЦ (Hash Table Search):
Использует хэш-функцию для нахождения элемента в соответствующем месте в хэш-таблице.
Обычно имеет временную сложность O(1), но может изменяться в зависимости от реализации и коллизий.

Разберем каждый алгоритм более подробно

================================
ЛИНЕЙНЫЙ ПОИСК (Linear Search):
================================

Описание:

Линейный поиск – это простой алгоритм поиска, перебирающий каждый элемент последовательно от начала до
конца коллекции для нахождения заданного значения.
Начиная с первого элемента алгоритм сравнивает его с целевым значением.
Если значение совпадает, поиск завершается и возвращается индекс найденного элемента.
Если значение не найдено, алгоритм продолжает поиск, переходя к следующему элементу в коллекции.
Этот процесс повторяется, пока не будет найдено совпадение или достигнут конец коллекции.
Сложность по времени:
В худшем случае: O(n), где n – количество элементов в коллекции. Все элементы должны быть проверены,
чтобы найти целевой.
В среднем случае: O(n/2).
В лучшем случае: O(1), когда целевое значение находится в первом элементе.
Сложность по пространству:
Пространственная сложность: O(1). Линейный поиск не требует дополнительной памяти, поскольку он работает
без создания дополнительных структур данных.

Пример:

public class LinearSearchExample {

    public static int linearSearch(int[] array, int target) {
        // Перебираємо кожен елемент масиву
        for (int i = 0; i < array.length; i++) {
            // Порівнюємо поточний елемент з цільовим значенням
            if (array[i] == target) {
                // Якщо знайдено збіг, повертаємо індекс елемента
                return i;
            }
        }
        // Якщо елемент не знайдено, повертаємо -1
        return -1;
    }

    public static void main(String[] args) {
        int[] array = {12, 45, 78, 23, 56, 34};
        int target = 23;

        // Викликаємо лінійний пошук
        int index = linearSearch(array, target);

        // Виводимо результат пошуку
        if (index != -1) {
            System.out.println("Елемент " + target + " знайдено за індексом " + index);
        } else {
            System.out.println("Елемент " + target + " не знайдено у масиві");
        }
    }
}

Результат:
Елемент 23 знайдено за індексом 3

Линейный поиск – прост и эффективен для небольших коллекций данных, хотя для больших объемов
может быть неэффективным.

================================
БИНАРНЫЙ ПОИСК (Binary Search):
================================

Описание:

Бинарный поиск – это эффективный алгоритм поиска, разработанный для упорядоченных данных.
Начиная с середины отсортированного массива алгоритм сравнивает искомое значение с центральным
элементом. Если искомое значение совпадает с центральным элементом, поиск завершается и
возвращается его индекс. Если искомое значение меньше или больше центрального элемента, поиск
продолжается в соответствующей половине массива. Этот процесс повторяется, пока не будет
найдено совпадение или достигнут конец поиска.

Сложность по времени:
В самом худшем случае: O(log n), где n – количество элементов в упорядоченной коллекции.
В среднем случае: O(log n).
В лучшем случае: O(1), когда целевое значение находится внутри упорядоченного массива.

Сложность по пространству:
Пространственная сложность: O(1). Бинарный поиск не требует дополнительной памяти, поскольку
работает с исходным упорядоченным массивом без создания дополнительных структур данных.

Пример:

public class BinarySearchExample {

    public static int binarySearch(int[] array, int target) {
        int left = 0;
        int right = array.length - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;

            // Перевіряємо, чи знайшли шукане значення
            if (array[mid] == target) {
                return mid;
            }

            // Якщо шукане значення менше середнього, змінюємо праву границю
            if (array[mid] < target) {
                left = mid + 1;
            }
            // Інакше змінюємо ліву границю
            else {
                right = mid - 1;
            }
        }

        // Якщо шукане значення не знайдено, повертаємо -1
        return -1;
    }

    public static void main(String[] args) {
        int[] array = {2, 5, 8, 12, 16, 23, 38, 56, 72, 91};
        int target = 23;

        // Викликаємо бінарний пошук
        int index = binarySearch(array, target);

        // Виводимо результат пошуку
        if (index != -1) {
            System.out.println("Елемент " + target + " знайдено за індексом " + index);
        } else {
            System.out.println("Елемент " + target + " не знайдено у масиві");
        }
    }
}

Результат:
Елемент 23 знайдено за індексом 5

Бинарный поиск – эффективный алгоритм для поиска упорядоченных данных, обеспечивающий быстрое
обнаружение элементов в больших коллекциях.

=======================================================
ПОИСК С ИСПОЛЬЗОВАНИЕМ ХЕШ-ТАБЛИЦ (Hash Table Search):
=======================================================

Описание:

Поиск с использованием хэш-таблиц – это алгоритм поиска, который использует хэш-таблицы для
быстрого доступа к данным. Элементы хранятся в хэш-таблице, где каждый элемент имеет свой
уникальный хэш-ключ. При поиске алгоритм вычисляет хэш-код целевого значения и использует
его для быстрой локализации элемента в таблице.

Сложность по времени:
В среднем случае O(1), поскольку большинство операций поиска могут быть выполнены за постоянное
время благодаря быстрому доступу к элементам в хэш-таблице.
В самом худшем случае: O(n), когда возникают коллизии, то есть несколько элементов имеют
одинаковый хэш-код и нужно выполнить дополнительный поиск среди них.

Сложность по пространству:
Пространственная сложность может быть O(n), где n – количество элементов в хэш-таблице, в
зависимости от размера таблицы и количества коллизий. Но за счет того, что размер таблицы может
быть адаптивно настроен, пространственная сложность часто меньше O(n).

Пример:

import java.util.HashMap;

public class HashTableSearchExample {
    public static void main(String[] args) {
        // Створення хеш-таблиці
        HashMap<Integer, String> hashMap = new HashMap<>();

        // Додавання елементів до хеш-таблиці
        hashMap.put(1, "Apple");
        hashMap.put(2, "Banana");
        hashMap.put(3, "Orange");
        hashMap.put(4, "Grape");
        hashMap.put(5, "Mango");

        // Виведення хеш-таблиці
        System.out.println("Хеш-таблиця: " + hashMap);

        // Пошук за ключем 3
        int keyToSearch = 3;
        if (hashMap.containsKey(keyToSearch)) {
            String value = hashMap.get(keyToSearch);
            System.out.println("Знайдено значення '" + value + "' за ключем " + keyToSearch);
        } else {
            System.out.println("Значення за ключем " + keyToSearch + " не знайдено");
        }
    }
}

Результат:
Хеш-таблиця: {1=Apple, 2=Banana, 3=Orange, 4=Grape, 5=Mango}
Знайдено значення 'Orange' за ключем 3

Поиск с использованием хэш-таблиц – быстрый и эффективный для поиска по ключу в больших коллекциях
данных, но может стать менее эффективным при большом количестве коллизий.

*
======================================================================================================
8) ДОПОЛНИТЕЛЬНЫЕ МАТЕРИАЛЫ

Java Algorithms and Implementations
https://howtodoinjava.com/java-algorithms-implementations/

Algorithms
https://java-programming.mooc.fi/part-7/2-algorithms

Sorting Algorithm
https://www.programiz.com/dsa/sorting-algorithm

Search Algorithms
https://www.freecodecamp.org/news/search-algorithms-linear-and-binary-search-explained/

*
======================================================================================================